<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><title>UE性能优化工具&nbsp;&nbsp;✦&nbsp; 有点笨有点猪</title><meta name="author" content="Davids"><meta name="keywords" content="Unreal Engine,Profile,Game AI"><meta name="description" content="CPUUnreal InsightUnreal Insights 在 Unreal Engine 4.24.3版本中开始支持移动平台性能数据录取。数据直接写入文件，GUI工具采集结束后离线解析数据文件。
优势：可长时间录制数据，数据在时间轴上以进程调度的形式展示，比较容易分析Game、RenderThread与WorkerThread的调度情况，从整体上结合时间连贯性对CPU瓶颈进行初步的定位。也"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/HUSTJJD/photos/avatar.jpeg"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="css/main.css"><script src="https://cdn.jsdelivr.net/npm/darkreader@4.9.58/darkreader.min.js"></script><script src="js/main.js"></script><script async>window.searchEngine="https://www.google.com/search?q=",window.homeHost="https://hustjjd.github.io"</script><script async reload src="https://cn.vercount.one/js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header id="header"><a id="title" href="index.html" class="logo"><img id="logo" src="https://cdn.jsdelivr.net/gh/HUSTJJD/photos/avatar.jpeg" alt="logo"> 有点笨有点猪</a><ul id="menu"><li class="menu-item"><a href="/about" class="menu-item-link">关于</a></li><li class="menu-item"><a href="https://github.com/HUSTJJD" class="menu-item-link item-icon" target="_blank"><i class="fa fa-github fa-2x"></i></a></li><li class="menu-item dark-mode"><a href="#" class="menu-item-link item-icon"><i class="fa fa-moon-o fa-2x"></i></a></li><script async>const localModel=localStorage.getItem("darkModel"),darkModel=localModel||0,darkModeIcon=document.querySelector("#menu .dark-mode i");1==darkModel&&(darkModeIcon.classList.replace("fa-moon-o","fa-sun-o"),DarkReader.enable({brightness:100,contrast:90,sepia:10})),darkModeIcon.addEventListener("click",()=>{const e=darkModeIcon.classList.contains("fa-moon-o");darkModeIcon.classList.toggle("fa-moon-o",!e),darkModeIcon.classList.toggle("fa-sun-o",e),localStorage.setItem("darkModel",e?1:0),e?DarkReader.enable({brightness:100,contrast:90,sepia:10}):DarkReader.disable()})</script></ul></header><script async>let startHeight=0;window.addEventListener("scroll",()=>{const{scrollY:t}=window,e=t-startHeight;startHeight=t,document.querySelector("#header").style.display=e>0&&t>50?"none":""})</script><div id="sidebar"><button id="sidebar-toggle" class="toggle"><i class="fa fa-arrow-right" aria-hidden="true"></i></button><div id="site-toc"><input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索"><div id="tree"><ul><li class="directory"><a class="directory" href="65fc9bfe.html" title="/65fc9bfe.htm"><i class="fa fa-plus-square-o"></i> Base Knowledge</a><div class="article-toc" style="display:none"></div><ul><li class="directory"><a class="directory" href="b391781d.html" title="/b391781d.htm"><i class="fa fa-plus-square-o"></i> Artificial Intelligence</a><div class="article-toc" style="display:none"></div><ul><li class="directory"><a class="directory" href="1b9a8a71.html" title="/1b9a8a71.htm"><i class="fa fa-plus-square-o"></i> Generative AI</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="a92685b9.html" title="/a92685b9.htm"><i class="fa fa-plus-square-o"></i> Reinforcement Learning</a><div class="article-toc" style="display:none"></div></li></ul></li></ul><ul><li class="directory"><a class="directory" href="a90338dd.html" title="/a90338dd.htm"><i class="fa fa-plus-square-o"></i> Computer Graphics</a><div class="article-toc" style="display:none"></div><ul><li class="directory"><a class="directory" href="fa3067f.html" title="/fa3067f.htm"><i class="fa fa-plus-square-o"></i> Animation</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="32a6bb76.html" title="/32a6bb76.htm">刚体</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="862df579.html" title="/862df579.htm">柔体</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="6a9b6571.html" title="/6a9b6571.htm">流体</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="2a5813d8.html" title="/2a5813d8.htm">质点-弹簧系统</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="6c246cfd.html" title="/6c246cfd.htm"><i class="fa fa-plus-square-o"></i> Geometry</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="95007b22.html" title="/95007b22.htm"><i class="fa fa-plus-square-o"></i> Rendering</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="151102e6.html" title="/151102e6.htm">实时光线追踪</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="af7a2452.html" title="/af7a2452.htm">实时全局光照</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="4bc335f8.html" title="/4bc335f8.htm">实时抗锯齿与超采样</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="3244508.html" title="/3244508.htm">实时渲染中的工业界技术</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="41600aa5.html" title="/41600aa5.htm">实时环境光照</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="f84f1a62.html" title="/f84f1a62.htm">实时阴影</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="e42b27d1.html" title="/e42b27d1.htm">实时高质量着色</a></li><div class="article-toc" style="display:none"></div></ul></li></ul></li></ul><ul><li class="directory"><a class="directory" href="f82e7011.html" title="/f82e7011.htm"><i class="fa fa-plus-square-o"></i> Computer Organization</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="73b8421c.html" title="/73b8421c.htm"><i class="fa fa-plus-square-o"></i> Data Structures & Algorithm</a><div class="article-toc" style="display:none"></div><ul><li class="directory"><a class="directory" href="612f48da.html" title="/612f48da.htm"><i class="fa fa-plus-square-o"></i> Basic Algorithm</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="ce28987a.html" title="/ce28987a.htm">Binary Lifting</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="fbb0c1cd.html" title="/fbb0c1cd.htm">Binary Search</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="122d1b7f.html" title="/122d1b7f.htm">Enumerate</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="4a214119.html" title="/4a214119.htm">Greedy</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="f28955a2.html" title="/f28955a2.htm">Recursion & Divide and Conquer</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="f1165d1c.html" title="/f1165d1c.htm">Sort</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="bf1dd6df.html" title="/bf1dd6df.htm">前缀和 & 差分</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="c8842ad8.html" title="/c8842ad8.htm"><i class="fa fa-plus-square-o"></i> Graph</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="18c42e2a.html" title="/18c42e2a.htm">Traverse</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="718acd86.html" title="/718acd86.htm"><i class="fa fa-plus-square-o"></i> Hash</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="a72bd85.html" title="/a72bd85.htm"><i class="fa fa-plus-square-o"></i> Linear</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="df95b584.html" title="/df95b584.htm"><i class="fa fa-plus-square-o"></i> Misc</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="9912b79f.html" title="/9912b79f.htm"><i class="fa fa-plus-square-o"></i> String</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="170cf1e2.html" title="/170cf1e2.htm"><i class="fa fa-plus-square-o"></i> Tree</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="18c42e2a.html" title="/18c42e2a.htm">Traverse</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="71b19194.html" title="/71b19194.htm"><i class="fa fa-plus-square-o"></i> Dynamic Programming</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="a80d0031.html" title="/a80d0031.htm">动态规划</a></li><div class="article-toc" style="display:none"></div></ul></li></ul></li></ul><ul><li class="file"><a href="de94bfed.html" title="/de94bfed.htm">Z Reference Link</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="directory"><a class="directory" href="9aec7ab9.html" title="/9aec7ab9.htm"><i class="fa fa-plus-square-o"></i> Compilation Principle</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="9ddd6f57.html" title="/9ddd6f57.htm">1 Overview</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="8ce73ad1.html" title="/8ce73ad1.htm">2 Lexical Analysis</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="d66ea0d0.html" title="/d66ea0d0.htm">3 Syntax Analysis</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="cbe0860d.html" title="/cbe0860d.htm">4 Syntax-Directed Translation</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="302b356c.html" title="/302b356c.htm">5 Intermediate Code Generation</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="acc2fc2f.html" title="/acc2fc2f.htm"><i class="fa fa-plus-square-o"></i> Computer Network</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="9ddd6f57.html" title="/9ddd6f57.htm">1 Overview</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="1d8aaf87.html" title="/1d8aaf87.htm">2 Application Layer</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="a9cf5148.html" title="/a9cf5148.htm">3 Transport Layer</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="f112baac.html" title="/f112baac.htm">4 Network Layer</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="adc18ede.html" title="/adc18ede.htm">5 Link Layer</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="b1e67c3e.html" title="/b1e67c3e.htm"><i class="fa fa-plus-square-o"></i> Operating system</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="9ddd6f57.html" title="/9ddd6f57.htm">1 Overview</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="9a0a76fa.html" title="/9a0a76fa.htm">2 并发</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="adb041e9.html" title="/adb041e9.htm">3 虚拟化</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="cf62193d.html" title="/cf62193d.htm">4 内核</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="75c85a55.html" title="/75c85a55.htm">5 持久化</a></li><div class="article-toc" style="display:none"></div></ul></li></ul></li></ul><ul><li class="directory"><a class="directory" href="874b5a85.html" title="/874b5a85.htm"><i class="fa fa-plus-square-o"></i> Programing</a><div class="article-toc" style="display:none"></div><ul><li class="directory"><a class="directory" href="38ea7f4b.html" title="/38ea7f4b.htm"><i class="fa fa-plus-square-o"></i> C#</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="f43812d6.html" title="/f43812d6.htm"><i class="fa fa-plus-square-o"></i> C&C++</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="2f9cafca.html" title="/2f9cafca.htm">C++对象模型</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="2ad255f1.html" title="/2ad255f1.htm">实现双端队列</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="ab0032e6.html" title="/ab0032e6.htm"><i class="fa fa-plus-square-o"></i> Code Style</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="c1fb7d19.html" title="/c1fb7d19.htm"><i class="fa fa-plus-square-o"></i> Cuda</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="4dbeaedc.html" title="/4dbeaedc.htm"><i class="fa fa-plus-square-o"></i> Design Pattern</a><div class="article-toc" style="display:none"></div><ul><li class="directory"><a class="directory" href="71a8a1ac.html" title="/71a8a1ac.htm"><i class="fa fa-plus-square-o"></i> 1 Creational</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="b80dfb29.html" title="/b80dfb29.htm">1 Factory Method 工厂方法</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="274180fd.html" title="/274180fd.htm">2 Abstract Factory</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="8c35c344.html" title="/8c35c344.htm">3 Builder</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="7bfb464b.html" title="/7bfb464b.htm">4 Prototype</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="7c49fddd.html" title="/7c49fddd.htm">5 Singleton</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="dead4f21.html" title="/dead4f21.htm">6 Summary</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="7901957b.html" title="/7901957b.htm"><i class="fa fa-plus-square-o"></i> 3 Behavioral</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="790949b5.html" title="/790949b5.htm">1 Chain of Responsibility</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="c3a3929a.html" title="/c3a3929a.htm">2 Command</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="9b6de4c4.html" title="/9b6de4c4.htm">3 Iterator</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="e03e130b.html" title="/e03e130b.htm">4 Mediator</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="bf71ebe9.html" title="/bf71ebe9.htm">5 Memento</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="3ade172.html" title="/3ade172.htm">6 Observer</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="53744b76.html" title="/53744b76.htm">7 State</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="924dd0cb.html" title="/924dd0cb.htm">8 Strategy</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="91bf0e85.html" title="/91bf0e85.htm">9 Template Method</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="2bc82489.html" title="/2bc82489.htm">10 Visitor</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="78952bdb.html" title="/78952bdb.htm">11 Interpreter</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="1f38bf3.html" title="/1f38bf3.htm">12 Summary</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="1b56872e.html" title="/1b56872e.htm"><i class="fa fa-plus-square-o"></i> 2 Structural</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="6d3820f7.html" title="/6d3820f7.htm">1 Adapter</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="b26119ff.html" title="/b26119ff.htm">2 Bridge</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="c9a00474.html" title="/c9a00474.htm">3 Composite</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="ebfe19bc.html" title="/ebfe19bc.htm">4 Decorator</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="462eceee.html" title="/462eceee.htm">5 Facade</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="1369d00.html" title="/1369d00.htm">6 Flyweight</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="83955033.html" title="/83955033.htm">7 Proxy</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="166f94b3.html" title="/166f94b3.htm">8 Summary</a></li><div class="article-toc" style="display:none"></div></ul></li></ul></li></ul><ul><li class="file"><a href="de94bfed.html" title="/de94bfed.htm">Z Reference Link</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="directory"><a class="directory" href="ee3c71cb.html" title="/ee3c71cb.htm"><i class="fa fa-plus-square-o"></i> Lua</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="9ddd6f57.html" title="/9ddd6f57.htm">1 Overview</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="87d98dd.html" title="/87d98dd.htm">2 Lua 5.x精要总结</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="34f08ad.html" title="/34f08ad.htm">3 Lua GC</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="5b0b3532.html" title="/5b0b3532.htm">4 Lua 虚拟机</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="937a4025.html" title="/937a4025.htm">5 Lua 面向对象</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="a378bd8e.html" title="/a378bd8e.htm"><i class="fa fa-plus-square-o"></i> Python</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="9ddd6f57.html" title="/9ddd6f57.htm">1 Overview</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="41002d9e.html" title="/41002d9e.htm"><i class="fa fa-plus-square-o"></i> Rust</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="72e1e9b5.html" title="/72e1e9b5.htm">1 基础</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="84539df9.html" title="/84539df9.htm"><i class="fa fa-plus-square-o"></i> Shell</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="9ddd6f57.html" title="/9ddd6f57.htm">1 Overview</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="d044eab7.html" title="/d044eab7.htm"><i class="fa fa-plus-square-o"></i> TypeScript</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="9ddd6f57.html" title="/9ddd6f57.htm">1 Overview</a></li><div class="article-toc" style="display:none"></div></ul></li></ul></li></ul><ul><li class="directory"><a class="directory" href="1615fe67.html" title="/1615fe67.htm"><i class="fa fa-plus-square-o"></i> Unreal Engine</a><div class="article-toc" style="display:none"></div><ul><li class="directory"><a class="directory" href="a7bb958f.html" title="/a7bb958f.htm"><i class="fa fa-plus-square-o"></i> AI</a><div class="article-toc" style="display:none"></div><ul><li class="directory"><a class="directory" href="37cfb5e6.html" title="/37cfb5e6.htm"><i class="fa fa-plus-square-o"></i> BehaviorTree</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="152a818d.html" title="/152a818d.htm"><i class="fa fa-plus-square-o"></i> EnvironmentQuery</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="5c7b52be.html" title="/5c7b52be.htm"><i class="fa fa-plus-square-o"></i> NavMesh</a><div class="article-toc" style="display:none"></div></li></ul></li></ul><ul><li class="directory"><a class="directory" href="fa3067f.html" title="/fa3067f.htm"><i class="fa fa-plus-square-o"></i> Animation</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="73533dd2.html" title="/73533dd2.htm">动画状态机</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="5a353d10.html" title="/5a353d10.htm"><i class="fa fa-plus-square-o"></i> Asset&Pak&Patch</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="cbbf2a71.html" title="/cbbf2a71.htm"><i class="fa fa-plus-square-o"></i> Core</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="f2421617.html" title="/f2421617.htm">UObject</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="ad6468a3.html" title="/ad6468a3.htm"><i class="fa fa-plus-square-o"></i> Debug</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="608296a3.html" title="/608296a3.htm"><i class="fa fa-plus-square-o"></i> Editor Extension</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="51fc19ed.html" title="/51fc19ed.htm"><i class="fa fa-plus-square-o"></i> GamePlay</a><div class="article-toc" style="display:none"></div><ul><li class="directory"><a class="directory" href="21270d9e.html" title="/21270d9e.htm"><i class="fa fa-plus-square-o"></i> Framwork</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="c4308202.html" title="/c4308202.htm">AGameModeBase</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="1c2d50fe.html" title="/1c2d50fe.htm">AGameStateBase</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="a131da00.html" title="/a131da00.htm"><i class="fa fa-plus-square-o"></i> Game Ability System</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="fad64f1c.html" title="/fad64f1c.htm">AGameplayCueNotify_Actor</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="b544f9e1.html" title="/b544f9e1.htm">FGameplayTag</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="321b2737.html" title="/321b2737.htm">UAbilitySystemComponent</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="c30a1442.html" title="/c30a1442.htm">UAbilityTask</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="76cb5781.html" title="/76cb5781.htm">UAttributeSet</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="4d5d44a8.html" title="/4d5d44a8.htm">UGameplayAbility</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="2303a7ba.html" title="/2303a7ba.htm">UGameplayEffect</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="d454ba70.html" title="/d454ba70.htm"><i class="fa fa-plus-square-o"></i> Replication</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="787d9e55.html" title="/787d9e55.htm">Optimization</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="2772613d.html" title="/2772613d.htm">Replication Graph</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="2d172444.html" title="/2d172444.htm">Significance Manager</a></li><div class="article-toc" style="display:none"></div></ul></li></ul></li></ul><ul><li class="directory"><a class="directory" href="178cde7f.html" title="/178cde7f.htm"><i class="fa fa-plus-square-o"></i> Physics</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="4eea9393.html" title="/4eea9393.htm"><i class="fa fa-plus-square-o"></i> Profile</a><div class="article-toc" style="display:none"></div><ul><li class="file active"><a href="" title="/3c5e942.htm">UE性能优化工具</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="9e936415.html" title="/9e936415.htm">Unity性能优化方向</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="95007b22.html" title="/95007b22.htm"><i class="fa fa-plus-square-o"></i> Rendering</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="f68f03c7.html" title="/f68f03c7.htm"><i class="fa fa-plus-square-o"></i> Sounds</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="891542da.html" title="/891542da.htm"><i class="fa fa-plus-square-o"></i> UI</a><div class="article-toc" style="display:none"></div></li></ul><ul><li class="directory"><a class="directory" href="fc559f4f.html" title="/fc559f4f.htm"><i class="fa fa-plus-square-o"></i> UnLua</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="558c8778.html" title="/558c8778.htm">Unlua指南</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="c7be2e.html" title="/c7be2e.htm">Unlua源码解析</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="file"><a href="de94bfed.html" title="/de94bfed.htm">Z Reference Link</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="directory"><a class="directory" href="c024b29d.html" title="/c024b29d.htm"><i class="fa fa-plus-square-o"></i> Platform</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="87a1b898.html" title="/87a1b898.htm">Java Native Interface</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="64c729ef.html" title="/64c729ef.htm">Unreal Plugin Language</a></li><div class="article-toc" style="display:none"></div></ul></li></ul></li></ul><ul><li class="directory"><a class="directory" href="b4b1f7ab.html" title="/b4b1f7ab.htm"><i class="fa fa-plus-square-o"></i> Work Experience</a><div class="article-toc" style="display:none"></div><ul><li class="directory"><a class="directory" href="8f308499.html" title="/8f308499.htm"><i class="fa fa-plus-square-o"></i> Efficiency</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="7db1f54a.html" title="/7db1f54a.htm">UE Project Git Pull&Build</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="directory"><a class="directory" href="3cedb797.html" title="/3cedb797.htm"><i class="fa fa-plus-square-o"></i> Security</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="e4aff432.html" title="/e4aff432.htm">哈希函数</a></li><div class="article-toc" style="display:none"></div></ul></li></ul><ul><li class="file"><a href="de94bfed.html" title="/de94bfed.htm">Z Reference Link</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="directory"><a class="directory" href="b7d46781.html" title="/b7d46781.htm"><i class="fa fa-plus-square-o"></i> Serialization</a><div class="article-toc" style="display:none"></div><ul><li class="file"><a href="cb358a7b.html" title="/cb358a7b.htm">Json</a></li><div class="article-toc" style="display:none"></div></ul><ul><li class="file"><a href="608ca7e8.html" title="/608ca7e8.htm">Protobuf</a></li><div class="article-toc" style="display:none"></div></ul></li></ul></li></ul><ul><li class="file"><a href="77cd4175.html" title="/77cd4175.htm">README</a></li><div class="article-toc" style="display:none"></div></ul></div></div></div><div id="content"><h1 id="article-title">UE性能优化工具</h1><div class="article-meta"><span>Davids</span> <span>2025-08-09 21:27:36</span><div id="article-categories"><span>Categories：</span> <span><i class="fa fa-folder" aria-hidden="true"><a href="/categories/Unreal-Engine/">Unreal Engine</a></i> ></span> <span><i class="fa fa-folder" aria-hidden="true"><a href="/categories/Unreal-Engine/Profile/">Profile</a></i></span> <span>Tags：</span></div></div><div id="article-content"><h1><span id="cpu">CPU</span></h1><h2><span id="unreal-insight">Unreal Insight</span></h2><p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/en-US/Engine/Performance/UnrealInsights/Overview/index.html">Unreal Insights</a> 在 Unreal Engine 4.24.3版本中开始支持移动平台性能数据录取。数据直接写入文件，GUI工具采集结束后离线解析数据文件。</p><p>优势：可长时间录制数据，数据在时间轴上以进程调度的形式展示，比较容易分析Game、RenderThread与WorkerThread的调度情况，从整体上结合时间连贯性对CPU瓶颈进行初步的定位。也可用于分析有规律的卡顿掉帧的情况。</p><p>劣势：所记录的调用堆栈较浅（可手动打点），较难定位到具体出问题的代码，人工分析需要时间与经验。</p><h2><span id="unreal-profiler">Unreal Profiler</span></h2><blockquote><p>UE5已删除此模块，建议使用 Unreal Insights</p></blockquote><p>Unreal Engine 中的 <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/en-US/TestingAndOptimization/PerformanceAndProfiling/Profiler/">Profiler</a>则是分析CPU端性能情况的一个老工具，与Unreal Insights相比它缺少了线程间调度情况的数据，优点在于其记录的调用堆栈深度较深，可与Insights结合使用 UE4引擎窗口中菜单DeveloperTools下SessionFrontend界面即为Profiler所在的窗口 可通过两种方法抓取数据：</p><ol><li>启动程序时增加参数：-messaging</li><li>游戏中使用命令： stat startfile, stat stopfile</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sdcard/UE4Game/YourProject/UE4CommandLine.txt ../../../YourProject/YourProject.uproject -messaging # 数据存放于 /sdcard/UE4Game/FPSDemo/FPSDemo/Saved/Profiling/UnrealStats</span><br></pre></td></tr></table></figure><p>通过Profiler数据就能看到更深的调用堆栈，比如这里就能看到GameEngine::Tick中不同代码的占用比例，左侧还有按类型分类的分组数据等，更多功能可参考Unreal<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/en-US/TestingAndOptimization/PerformanceAndProfiling/Profiler/">官方文档</a></p><h2><span id="simpleperf">Simpleperf</span></h2><p>Simpleperf可录制很深的CPU调用堆栈，可用于详细分析问题时间内的CPU代码执行情况，其将数据聚合，输出类似于Instrument TimeProfiler的形式，可以看到不同函数在一段时间内的贡献、占比情况，及调用次数，方便对其进行更有针对性的优化。但这种聚合模式没有单帧的概念，主要用于宏观统计。因此可以与Profiler、Insights等工具结合使用。</p><blockquote><p>建议使用Test包进行数据分析<br>避免Development版本额外代码所造成的性能压力影响真实数据</p></blockquote><p>原理简介：</p><p>与Instrument TimeProfiler相同，使用<a target="_blank" rel="noopener" href="https://jvns.ca/blog/2016/03/12/how-does-perf-work-and-some-questions/">采样</a>的概念进行CPU数据分析 现代CPU拥有<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ddi0433/c/performance-monitoring-unit/about-the-performance-monitoring-unit?lang=en">PMU（Performance Monitor Unit）</a>单元，通过Counter寄存器可得到精确的Cycle Count等CPU Performance数据</p><p><a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/README.md">simpleperf</a>基于linux的<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/perf_event_open.2.html">perf</a>改造而来，要记录与代码相关的性能数据，就需要记录目标线程的<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/v4.3/arch/x86/kernel/perf_regs.c#L114-L118">寄存器</a> 因此存储寄存器数据就是采样的主要工作之一，存储的频率就是采样的频率，采样的频率不能太高，是为了性能与存储的角度考虑的 理论上数据量越大，基于采样的数据经过统计学处理后就越接近真实数据</p><p>可通过NDK中的工具进行真机数据录制，UE427建议使用 NDK r21d 版本</p><p>通过下方Python脚本即可自动采集并生成火焰图与Android Studio可打开的Perf数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python simpleperf.py ndkpath symbolpath/symbolfile -duration=10[optional] -app=com.tencent.dummy[optional]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> fnmatch</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parseargs</span>(<span class="params">args</span>):</span><br><span class="line">    ndkpath_ = args[<span class="number">1</span>]</span><br><span class="line">    symbolpath_ = args[<span class="number">2</span>]</span><br><span class="line">    app_ = <span class="string">&#x27;com.tencent.dummy&#x27;</span></span><br><span class="line">    duration_ = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(args) &gt; <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args[<span class="number">3</span>:]:</span><br><span class="line">            words_ = arg.split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">len</span>(words_) &lt; <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (words_[<span class="number">0</span>] == <span class="string">&#x27;-duration&#x27;</span>):</span><br><span class="line">                duration_ = <span class="built_in">int</span>(words_[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> (words_[<span class="number">0</span>] == <span class="string">&#x27;-app&#x27;</span>):</span><br><span class="line">                app_ = words_[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ndkpath_, symbolpath_, app_, duration_</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_files</span>(<span class="params">directory, pattern</span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(directory):</span><br><span class="line">        <span class="keyword">for</span> basename <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> fnmatch.fnmatch(basename, pattern):</span><br><span class="line">                filename = os.path.join(root, basename)</span><br><span class="line">                <span class="keyword">yield</span> filename</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readforpackagename</span>(<span class="params">filepath, packagename</span>):</span><br><span class="line">    perftxt_ = <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (perftxt_ <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;failed to read file &#123;0&#125;!&#x27;</span>.<span class="built_in">format</span>(filepath))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    lines_ = perftxt_.readlines()</span><br><span class="line">    perftxt_.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Android 10</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines_[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">match</span> = re.search(<span class="string">&#x27;/data/app/&#x27;</span> + packagename + <span class="string">&#x27;\\S+&#x27;</span>, line)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">match</span>.group(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Android 11</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines_[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">match</span> = re.search(<span class="string">&#x27;/data/app/\\S+&#x27;</span> + packagename + <span class="string">&#x27;\\S+&#x27;</span>, line)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">match</span>.group(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">args</span>):</span><br><span class="line">    ndkpath_, symbolpath_, app_, duration_ = parseargs(args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (os.path.isfile(symbolpath_) <span class="keyword">is</span> <span class="literal">False</span>):</span><br><span class="line">        <span class="keyword">for</span> possiblesymbol <span class="keyword">in</span> find_files(symbolpath_, <span class="string">&#x27;*.so&#x27;</span>):</span><br><span class="line">            symbolpath_ = possiblesymbol</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ndk: &#123;0&#125;\nsymobl: &#123;1&#125;\napp: &#123;2&#125;\nduration: &#123;3&#125;\n&#x27;</span>.<span class="built_in">format</span>(ndkpath_, symbolpath_, app_, duration_))</span><br><span class="line"></span><br><span class="line">    perfpath_ = ndkpath_ + <span class="string">&#x27;/simpleperf/bin/android/arm64/simpleperf&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (os.path.isfile(perfpath_) <span class="keyword">is</span> <span class="literal">False</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;file &#123;0&#125; not found!&#x27;</span>.<span class="built_in">format</span>(perfpath_))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># push simplerperf executable to mobile</span></span><br><span class="line">    subprocess.call(<span class="string">&#x27;adb push &#x27;</span> + perfpath_ + <span class="string">&#x27; /data/local/tmp&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># setup simpleperf permission</span></span><br><span class="line">    subprocess.call(<span class="string">&#x27;adb shell chmod a+x /data/local/tmp/simpleperf&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># fix &#x27;too many open files&#x27; error</span></span><br><span class="line">    subprocess.call(<span class="string">&#x27;adb shell ulimit -n 2048&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># -f 6000, higher sampling frequency for more accurate profiling</span></span><br><span class="line">    subprocess.call(</span><br><span class="line">        <span class="string">&#x27;adb shell \&quot;cd /data/local/tmp/ &amp;&amp; simpleperf record -g --app &#123;0&#125; --duration &#123;1&#125; -f 6000 &amp; exit\&quot;&#x27;</span>.<span class="built_in">format</span>(app_, duration_), shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pull perf.data</span></span><br><span class="line">    subprocess.call(<span class="string">&#x27;adb pull /data/local/tmp/perf.data perf.data&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    perfexe_ = ndkpath_ + <span class="string">&#x27;/simpleperf/bin/windows/x86_64/simpleperf.exe&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (os.path.isfile(perfexe_) <span class="keyword">is</span> <span class="literal">False</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;file &#123;0&#125; not found!&#x27;</span>.<span class="built_in">format</span>(perfexe_))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># setup binary_cache folder</span></span><br><span class="line">    subprocess.call(perfexe_ + <span class="string">&#x27; report -i perf.data -o perf.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    packagename_ = readforpackagename(<span class="string">&#x27;perf.txt&#x27;</span>, app_)</span><br><span class="line">    <span class="keyword">if</span> packagename_ == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;package &#123;0&#125; not found!&#x27;</span>.<span class="built_in">format</span>(app_))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;package name: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(packagename_))</span><br><span class="line"></span><br><span class="line">    bianrycachepath_ = ndkpath_ + <span class="string">&#x27;/simpleperf/binary_cache/&#x27;</span> + packagename_.replace(<span class="string">&#x27;libUE4.so&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;package name: &#123;0&#125;\nbinary cache: &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(packagename_, bianrycachepath_))</span><br><span class="line"></span><br><span class="line">    shutil.rmtree(ndkpath_ + <span class="string">&#x27;/simpleperf/binary_cache/&#x27;</span>, ignore_errors=<span class="literal">True</span>)</span><br><span class="line">    os.makedirs(bianrycachepath_)</span><br><span class="line"></span><br><span class="line">    shutil.copy2(symbolpath_, bianrycachepath_)</span><br><span class="line"></span><br><span class="line">    curfolder_ = os.path.abspath(os.getcwd())</span><br><span class="line"></span><br><span class="line">    subprocess.call(perfexe_ + <span class="string">&#x27; report -i perf.data -o perf.caller.txt -g caller -n --full-callgraph --symfs &#x27;</span> + ndkpath_ + <span class="string">&#x27;/simpleperf/binary_cache/&#x27;</span>)</span><br><span class="line">    subprocess.call(perfexe_ + <span class="string">&#x27; report -i perf.data -o perf.callee.txt -g callee -n --full-callgraph --symfs &#x27;</span> + ndkpath_ + <span class="string">&#x27;/simpleperf/binary_cache/&#x27;</span>)</span><br><span class="line">    subprocess.call(<span class="string">&#x27;python report_html.py -i &#123;0&#125;/perf.data -o &#123;0&#125;/perf.html --no_browser&#x27;</span>.<span class="built_in">format</span>(curfolder_, curfolder_), cwd=ndkpath_+<span class="string">&#x27;/simpleperf/&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># convert perf.data to Android Studio openable perf.trace</span></span><br><span class="line">    subprocess.call(perfexe_ + <span class="string">&#x27; report-sample --protobuf --show-callchain -i perf.data -o perf.trace&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Usage: python simpleperf.py `ndk path` `libUE4.so symbol path` -app=com.tencent.dummy[optional] -duration=10[optional, in seconds]&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    start(sys.argv)</span><br></pre></td></tr></table></figure><h3><span id="android-studio">Android Studio</span></h3><p>使用Android Studio的 <a target="_blank" rel="noopener" href="https://developer.android.com/studio/profile/apk-profiler">ProfileAPK</a> 功能，即可较为自动的生成性能数据</p><h3><span id="perfetto">Perfetto</span></h3><p><a target="_blank" rel="noopener" href="https://perfetto.dev/">https://perfetto.dev/</a></p><p>可以拿到simpleperf、systrace等数据</p><p>可用于分析APP、系统整体CPU调度，渲染节奏等问题</p><h2><span id="cachesim">CacheSim</span></h2><p>虚幻引擎设计成熟，核心代码流程上，算法、结构层面的优化已难以挖掘水分</p><p>对于一些自行实现或引擎自身模块，在算法层面无优化手段后，可针对性的进行Cache优化</p><p>使用软件模拟AMD CPU指令集，统计出出现Cache Miss的<strong>代码行</strong>，助力深度CPU性能分析</p><p>缺点：仅可在Windows、Linux平台进行软件模拟</p><p>[挤掉Cache Miss的水分：Cascade粒子系统的优化（一）]</p><p>[GDC2017 | Cold, Hard Cache: Insomniac’s Cache Simulator]</p><h2><span id="arm-streamline">Arm Streamline</span></h2><p><a target="_blank" rel="noopener" href="https://developer.arm.com/Tools%20and%20Software/Arm%20Mobile%20Studio">Arm Mobile Studio 2022</a>版本除了常见CPU Counter的采集之外，与CacheSim一样支持了针对代码行的Cache分析</p><p>优势：真机跑数据，硬件Counter更准确，参考价值更高</p><p><a target="_blank" rel="noopener" href="https://developer.arm.com/Tools%20and%20Software/Streamline%20Performance%20Analyzer">Arm Streamline Performance Analyzer</a> 支持采集Arm芯片的GPU、CPU Counter数据，支持CI 并支持结合Event采样，将Counter数据与源码建立联系 <a target="_blank" rel="noopener" href="https://developer.arm.com/Additional%20Resources/Video%20Tutorials/Arm%20Mali%20GPU%20Training%20-%20EP3-3">官方教学视频</a></p><p>通过此工具可分析移动平台真机CPU指令执行过程中的Cache、Branch等情况，以更深入且精准的优化游戏CPU端性能表现</p><p><strong>建议使用Test包进行数据采集</strong></p><p>【1】选择需要采集的Counter：</p><p>右上角有模板，针对你的需要，选择CPU Cache（Cache Miss）、Branching（分支预测失败）、Clock（执行时间）等模板：</p><p>红色圈圈代表对此Counter进行Event-based sampling，即将Counter与执行代码结合 当Counter触发 Threshold（默认是1000）次后，进行一次执行堆栈的采样 Cache Miss相关Counter的介绍：</p><p>【2】设置采集参数</p><p>将带符号表的libUE4.so添加到Program Images中</p><p>Frequency：Normal（采样率越高，对频繁调用的小函数侦听越准确，但数据量与性能会大大下降，可根据采集结果权衡设置）</p><p>Buffer Mode：Streaming</p><p>打开堆栈回溯（打开no-omit-frame-pointer编译选项）</p><p>最终根据Counter数据，生成的报告所采取的采样比率，同样是越高越精准</p><p><strong>数据解析</strong></p><blockquote><p>可先拉起游戏运行至需要测试的玩法、地点，尽可能短时的采集数据</p></blockquote><p>开始采集后，点击左侧Stop按钮🛑停止采集，将自动生成报告</p><p>【1】Call Paths</p><p>以调用堆栈的形式展示所选Counter Sample Event的命中情况：精确到函数</p><p>双击可跳转至 Code 页签</p><p>【2】Functions</p><p>以函数列表形式展示Counter Sample Event命中情况</p><p>双击可跳转至 Code 页签</p><p>【3】Code</p><p>工具支持Counter（Cache Miss）数据归因（Attribution），即指明发生Cache Miss的位置 但因为现代CPU乱序执行等优化手段，加上基于堆栈采样的数据聚合原理，数据仅供参考 但已足够分析出问题函数中问题代码的位置：</p><p>如上图中大概是PrimitiveProxy的获取不连续，导致的CacheMiss，需要结合上下文进行分析，确认真正问题所在</p><blockquote><p>看上去行号不能精确对上？<br>解释见此<a target="_blank" rel="noopener" href="https://community.arm.com/support-forums/f/graphics-gaming-and-vr-forum/54427/streamline-analyze-performance">文章</a></p></blockquote><h2><span id="xcode-timeprofiler">XCode Timeprofiler</span></h2><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2019/411/">https://developer.apple.com/videos/play/wwdc2019/411/</a></p><p>与Simpleperf原理相同的CPU性能分析工具，功能强大</p><h2><span id="best-practice">Best Practice</span></h2><p>粗粒度工具：FramePro、UnrealInsight 用于开发期CI暴漏明显问题</p><p>发现问题后，使用细粒度工具进行深度分析：Simpleperf、Streamline、TimeProfiler</p><p>建议使用Test包，排除Cache、冗余代码、Profiler本身对性能的影响</p><p>尝试：离线计算、ParallelFor、异步化、SOA化等方案</p><p>并使用CacheSim、Streamline进行 Cache Miss 分析，压榨出最后的水分</p><p>实例一：GC垃圾回收</p><p><strong>偶发大负载任务，充分利用可能空闲的线程</strong></p><p><strong>ParallelFor 进行 LockFree 优化</strong></p><p>UE垃圾回收扫描引用时，将引用分析抛到多个Task线程处理</p><p>但GC时通常会阻塞Game、RHI、Render等线程，可充分利用可能空闲的这些大核线程，进一步提升性能：</p><h3><span id="实例二全局变量与cache-miss">实例二：全局变量与Cache Miss</span></h3><p>将其挪出ParallelFor中的Lambda：</p><h1><span id="gpu">GPU</span></h1><p>现代Mobile GPU通常使用 <a target="_blank" rel="noopener" href="https://blog.imaginationtech.com/understanding-powervr-series5xt-powervr-tbdr-and-architecture-efficiency-part-4/">TBR、TBDR</a> 硬件架构</p><p>在有限的功耗下提供尽可能多的性能空间</p><p>除了控制 运算负载、动态分支、全精度运算 等天然GPU不友好的指标之外</p><p>Mobile GPU因其On-chip Memory较小的原因</p><p>需要严格控制寄存器数量，避免Register Spill产生额外IO带宽</p><h2><span id="adreno-gpu">Adreno GPU</span></h2><p><a target="_blank" rel="noopener" href="https://developer.qualcomm.com/sites/default/files/docs/adreno-gpu/developer-guide/gpu/gpu.html">https://developer.qualcomm.com/sites/default/files/docs/adreno-gpu/developer-guide/gpu/gpu.html</a></p><p>介绍Adreno GPU counter指标与建议值</p><p>使用Snapdragon Profiler进行Counter数据抓取</p><p>提供python脚本进行Counter数据汇总与分类</p><p>其次选择Realtime项，打开app后</p><p>在下方双击System分组的所有GPU相关指标，即可自动开始记录Counter数据：</p><blockquote><p>高通不建议使用Process分组的指标，经测试发现会导致865频率降低的bug，直接采集全屏游戏时System组的性能数据</p></blockquote><p>采集完毕后点击暂停按钮：</p><p>后点击csv按钮输出Counter数据，即可通过python脚本进行简单的数据分析</p><p><strong>Counter介绍</strong></p><ul><li><p><code>% Anisotropic Filtered</code><br>Percent of texels filtered using the ‘Anisotropic’ sampling method.<br>各向异性过滤比例，尽量多使用双线性过滤，当然一些比如地形之类的贴图还是需要使用各向异性过滤，保证在30%以下</p></li><li><p><code>% Linear Filtered</code><br>Percent of texels filtered using the ‘Linear’ sampling method.<br>双线性过滤比例，尽量使用它</p></li><li><p><code>% Nearest Filtered</code><br>Percent of texels filtered using the ‘Nearest’ sampling method.<br>Nearest过滤比例</p></li><li><p><code>% Non-Base Level Textures</code><br>Percent of texels coming from a non-base MIP level.<br>采样到非第零级mipmap的比例，越高越好，使用次级mip可以减少内存带宽的使用</p></li><li><p><code>% Prims Clipped</code><br>Percentage of primitives clipped by the GPU (where new<br>primitives are generated).<br>For a primitive to be clipped, it has to have a visible portion inside<br>the viewport but extend outside the ‘guardband’ an area that surrounds<br>the viewport and significantly reduces the number of primitives the<br>hardware has to clip.<br>GPU剔除掉的面数比例，即模型有一部分摄像机看不到，硬件帮你剔除的情况</p></li><li><p><code>% Prims Trivially Rejected</code><br>Percentage of primitives that are trivially rejected.<br>A primitive can be trivially rejected if it is outside the visible<br>region of the render surface. These primitives are ignored by the<br>rasterizer.<br>完全没有贡献的面。即完全不在相机里的面，尽量将此类模型在CPU上就剔除掉</p></li><li><p><code>% Shader ALU Capacity Utilized</code><br>Percent of maximum shader capacity (ALU operations) utilized.<br>For each cycle that the shaders are working, the average percentage of<br>the total shader ALU capacity that is utilized for that cycle.<br>ALU的利用率，一般情况下越高越好，因为你充分利用了GPU的数学运算能力</p></li><li><p><code>% Shaders Busy</code><br>Percentage of time that all Shader cores are busy.<br>Shader Core有工作的比例，包括ALU、TPU、LoadStore的情况。当然，也包括Memory Fetch Stall时等待的比例<br>现代的GPU会在发生Stall时，尝试去切换线程，让GPU一致忙起来，以此来“掩盖”这种内存导致的Stall</p></li><li><p><code>% Stalled on System Memory</code><br>Percentage of cycles the L2 cache is stalled waiting for data from system memory.<br>L2 cache未命中，等待DRAM数据时产生的延迟的比例<br>如果此指标过高，可能是你采样的数据的空间连续性比较差，减少Dependent Texture Fetch等</p></li><li><p><code>% Texture Fetch Stall</code><br>Percentage of clock cycles where the shader processors cannot<br>make any more requests for texture data.<br>A high value for this metric implies the shaders cannot get texture data<br>from the texture pipe (L1, L2 cache or memory) fast enough, and<br>rendering performance may be negatively affected.<br>Shader Core因为正在等待贴图相关内存IO而产生空转的比例<br>可能是没开Mipmap或使用的贴图分辨率过大，或采样贴图的UV空间连续性太差了</p></li><li><p><code>% Texture L1 Miss</code><br>Number of L1 texture cache misses divided by L1 texture cache<br>requests.<br>This metric does not consider how many texture requests are made per<br>time period (like the ‘% GPU L1 Texture cache miss’ metric), but is<br>simple miss to request ratio.<br>贴图L1 cache未命中的比例</p></li><li><p><code>% Texture L2 Miss</code><br>Number of L2 texture cache misses divided by L2 texture cache requests.<br>This metric does not consider how many texture requests are made per time period, but is simple miss to request ratio.<br>贴图L2 cache未命中的比例</p></li><li><p><code>% Time ALUs Working</code><br>Percentage of time the ALUs are working while the Shaders are busy.<br>Shader Core busy时，ALU在工作的比例，理想的这个比例应该尽可能地高</p></li><li><p><code>% Time Compute</code><br>Amount of time spent in compute work compared to the total time spent shading everything.<br>Shader Core busy时，Compute计算单元工作的比例</p></li><li><p><code>% Time EFUs Working</code><br>Percentage of time the EFUs are working while the Shaders are busy.<br>Elementary functional unit (复杂函数sin、log等运算单元)，理想的此比例应该尽可能地低</p></li><li><p><code>% Time Shading Fragments</code><br>Amount of time spent shading fragments compared to the total time spent shading everything.<br>渲染Fragment运算时的比例</p></li><li><p><code>% Time Shading Vertices</code><br>Amount of time spent shading vertices compared to the total time spent shading everything.<br>处理Vertices运算时的比例</p></li><li><p><code>% Vertex Fetch Stall</code><br>Percentage of clock cycles where the GPU cannot make any more<br>requests for vertex data.<br>A high value for this metric implies the GPU cannot get vertex data from<br>memory fast enough, and rendering performance may be negatively<br>affected.<br>当GPU因为内存IO问题无法获取vertex数据时的比例。可能是场景顶点数过多的缘故，理想的输入GPU的顶点数应保持在300K-500K的数量级</p></li><li><p><code>ALU / Fragment</code><br>Average number of scalar fragment shader ALU instructions<br>issued per shaded fragment, expressed as full precision ALUs (2 mediump &#x3D;<br>1 fullp).<br>Includes interpolation instruction. Does not include vertex shader<br>instructions.<br>平均处理每个Fragment的运算中，ALU相关的指令数（记录全精度ALU，也包括interpolation的指令）</p></li><li><p><code>ALU / Vertex</code><br>Average number of vertex scalar shader ALU instructions issued per shaded vertex.<br>Does not include fragment shader instructions.<br>平均处理每个Vertex的运算中，ALU相关的指令数</p></li><li><p><code>Average Polygon Area</code><br>Average number of pixels per polygon.<br>Adreno’s binning architecture will count a primitive for each ‘bin’ it<br>covers, so this metric may not exactly match expectations.<br>每个面平均有多少像素，这个值可能不太准，理想的10-15像素&#x2F;面</p></li><li><p><code>Average Vertices / Polygon</code><br>Average number of vertices per polygon.<br>This will be around 3 for triangles, and close to 1 for triangle strips.<br>平均每个面有多少顶点</p></li><li><p><code>Avg Bytes / Fragment</code><br>Average number of bytes transferred from main memory for each fragment.<br>每个Fragment运算过程中传输到DRAM的内存的字节数</p></li><li><p><code>Avg Bytes / Vertex</code><br>Average number of bytes transferred from main memory for each vertex.<br>每个Vertext运算过程中传输到DRAM的内存的字节数</p></li><li><p><code>Avg Preemption Delay</code><br>Average time (us) from the preemption request to preemption start.<br>GPU线程抢占（类似CPU线程调度，将数据写入DRAM）所产生的延迟的比例</p></li><li><p><code>Clocks / Second</code><br>Number of GPU clocks per second.<br>GPU的频率，满频时采集数据比较有参考性</p></li><li><p><code>EFU / Fragment</code><br>Average number of scalar fragment shader EFU instructions issued per shaded fragment.<br>Does not include Vertex EFU instructions<br>每个Fragment中EFU复杂运算的平均数量，越低越好</p></li><li><p><code>EFU / Vertex</code><br>Average number of scalar vertex shader EFU instructions issued per shaded vertex.<br>Does not include fragment EFU instructions<br>每个Vertex中EFU复杂运算的平均数量，越低越好</p></li><li><p><code>Fragment ALU Instructions / Sec (Full)</code><br>Total number of full precision fragment shader instructions issued, per second.<br>Does not include medium precision instructions or texture fetch instructions.<br>Fragment中每秒里全精度ALU指令的平均数量，<strong>移动GPU要尽全力使用半精度运算</strong>，Fragment中除了位置运算，基本用半精度就足够<br>既能加快运算，也能降低带宽也能减少发生register spill的比例</p></li><li><p><code>Fragment ALU Instructions / Sec (Half)</code><br>Total number of half precision Scalar fragment shader instructions issued, per second.<br>Does not include full precision instructions or texture fetch instructions.<br>Fragment中每秒里半精度ALU指令的平均数量，<strong>移动GPU要尽全力使用半精度运算</strong></p></li><li><p><code>Fragment EFU Instructions / Second</code><br>Total number of Scalar fragment shader Elementary Function Unit (EFU) instructions issued, per second.<br>These include math functions like sin, cos, pow, etc.<br>Fragment中每秒里EFU指令数，当然是越少越好</p></li><li><p><code>Fragment Instructions / Second</code><br>Total number of fragment shader instructions issued, per<br>second.<br>Reported as full precision scalar ALU instructions 2 medium precision<br>instructions equal 1 full precision instruction. Also includes<br>interpolation instructions (which are executed on the ALU hardware) and<br>EFU (Elementary Function Unit) instructions. Does not include texture<br>fetch instructions.<br>Fragment中每秒的所有指令数（ALU计算的是全精度，也包含interpolation与EFU，不包含贴图fetch指令）</p></li><li><p><code>Fragments Shaded / Second</code><br>Number of fragments submitted to the shader engine, per second.<br>每秒提交到Shader Core中的Fragmenet数量，理论上与分辨率，MSAA等有关</p></li><li><p><code>GPU % Bus Busy</code><br>Approximate Percentage of time the GPU’s bus to system memory is busy.<br>大致计算的GPU等待DRAM IO的情况，如果比例较高，就是带宽过大了，如果目标时60FPS，保证带宽在80M&#x2F;frame，3-5G&#x2F;sec</p></li><li><p><code>GPU % Utilization</code><br>Percentage of GPU utilized as measured at peak GPU clock(585Mhz) and capacity<br>GPU满频率跑时的比例</p></li><li><p><code>GPU Frequency</code><br>GPU frequency in Hz</p></li><li><p><code>L1 Texture Cache Miss Per Pixel</code><br>Average number of Texture L1 cache misses per pixel.<br>Lower values for this metric imply better memory coherency. If this<br>value is high, consider using compressed textures, reducing texture<br>usage, etc.<br>每个像素L1 Texture Cache未命中的数量。缓存利用率与数据请求的内存相关性有关<br>L1 Cache大致建议在20%左右</p></li><li><p><code>Pre-clipped Polygons/Second</code><br>Number of polygons submitted to the GPU, per second, before any hardware clipping.<br>每秒提交到GPU准备进行Culling的面数，可见面数&#x2F;提交总面数的比例高于50%时是比较健康的<br>否则，给SOC、HOC一些压力，多在渲染前剔除无用的数据</p></li><li><p><code>Preemptions / second</code><br>The number of GPU preemptions that occurred, per second.<br>每秒发生GPU抢占的次数，抢占过多可能是GPU负载太重了</p></li><li><p><code>Read Total (Bytes/sec)</code><br>Total number of bytes read by the GPU from memory, per second.<br>每秒总读带宽，读带宽一般比写带宽高一些，因为Vertex分Tile需要将数据写入DRAM并多次读出，贴图的读取也属于读带宽</p></li><li><p><code>Reused Vertices / Second</code><br>Number of vertices used from the post-transform vertex buffer<br>cache.<br>A vertex may be used in multiple primitives; a high value for this<br>metric (compared to number of vertices shaded) indicates good re-use of<br>transformed vertices, reducing vertex shader workload.<br>复用的顶点的比例，模型的大部分顶点都可以焊接起来，这样不同的三角形就可以公用顶点，减少数据量与Shader负载<br>这个值相比于总处理的顶点数，占比越高当然越好，如果比较低，就处理一下模型，尽量公用顶点</p></li><li><p><code>SP Memory Read (Bytes/Second)</code><br>Bytes of data read from memory by the Shader Processors, per second.<br>Shader Processor每秒所读取的内存总数</p></li><li><p><code>Texture Memory Read BW (Bytes/Second)</code><br>Bytes of texture data read from memory per second.<br>Includes bytes of platform compressed texture data read from memory.<br>贴图总读带宽，一般都是贴图读带宽是读带宽中比较高的</p></li><li><p><code>Textures / Fragment</code><br>Average number of textures referenced per fragment.<br>每个Frament平均使用的贴图数量</p></li><li><p><code>Textures / Vertex</code><br>Average number of textures referenced per vertex.<br>每个Vertex平均使用的贴图的数量</p></li><li><p><code>Vertex Instructions / Second</code><br>Total number of scalar vertex shader instructions issued, per<br>second.<br>Includes full precision ALU vertex instructions and EFU vertex<br>instructions. Does not include medium precision instructions (since<br>they are not used for vertex shaders). Does not include vertex fetch or<br>texture fetch instructions.<br>每秒Vertex shader指令总数（不包含Vertex fetch和贴图fetch指令）</p></li><li><p><code>Vertex Memory Read (Bytes/Second)</code><br>Bytes of vertex data read from memory per second.<br>每秒从DRAM中读取的顶点数据的总大小</p></li><li><p><code>Vertices Shaded / Second</code><br>Number of vertices submitted to the shader engine, per second.<br>每秒提交给Shader Core的顶点数</p></li><li><p><code>Write Total (Bytes/sec)</code><br>Total number of bytes written by the GPU to memory, per second.<br>总写带宽，写带宽如果高于读带宽，就是不正常的，关注一下Shader的Register Spill，load&#x2F;store，image store等<br>甚至可能是GPU驱动的BUG，或Shader写法触发的编译器的BUG</p></li></ul><blockquote><p>Snapdragon Profiler Snapshot 可查看 DrawCall 所执行的 Shader 寄存器使用信息</p></blockquote><h2><span id="mali-gpu">Mali GPU</span></h2><p>[【公司】MTK技术专场研讨会回顾（1112）]</p><p>下方的 Midgard&#x2F;Bifrost&#x2F;Valhall ISA Config标明了不同架构GPU的可用线程数与可用寄存器的信息</p><p>比如Mali-G78，可用Work寄存器是64个（每个32bit，即一个vec4）</p><blockquote><p>当你的Shader使用的Work寄存器数量大于64时，就会发生Register Spill，会有额外的带宽消耗与性能损耗</p></blockquote><p>Uniform寄存器的的上限是128&#x2F;Draw，它是独立的资源，被一个Shader Program所发起的所有线程共享</p><blockquote><p>当你的Shader使用的Uniform寄存器数量大于128时，GPU会需要从LSC中读取超出的寄存器数据，产生额外带宽消耗</p></blockquote><p>可使用Mali-offline-compiler查看Shader的寄存器信息：</p><p>PerfDog也支持输出部分Mali GPU counter数据：</p><blockquote><p>与 HWCPipe使用相同硬件接口</p></blockquote><h3><span id="g77-gpu-counters介绍">G77 GPU Counters介绍</span></h3><p><strong>GPU Activity</strong></p><p>从整体上分析GPU队列的处理情况，并且看到Fragment和非Fragment处理的比例</p><p>G77上的任务负载通过 Job Manager管理调度</p><p>它为驱动层暴漏了两个FIFO的任务队列，叫Job Slots</p><p>一个Slot为非Fragment任务服务（Compute、Vertex），一个为Fragment着色任务服务</p><p>这两个队列和CPU的交互是异步的，并且他们可以并行执行</p><p>下图展示了不同任务下GPU处理数据的路径，以及与路径相关的性能Counter</p><p>注意有的Counter统计的是整个数据路径下的情况，并不代表某个硬件单元</p><p>比如Fragment queue active cycles会在GPU任何硬件单元有运行fragment任务时增加cycle count</p><p>另外，有些Counter会统计到多条数据路径的表现信息</p><p>比如Fragment&#x2F;Non-Fragment着色程序都是在Unified执行核心上运行的</p><p>下面这张游道图就展示了顶层Job Manager的Counter在有重叠的渲染流程中增加计数的</p><p>这张图用不同的蓝色展示了每帧里出现的两个渲染流程</p><p>每个流程都先有Non-Fragment Work开始，以Fragment Work结束（因为要先VS才能FS）</p><p>每段任务结束后，GPU都会通知到CPU</p><p>注意，只要队列里有任务，GPU active cycles就会增加</p><p><strong>GPU Usage</strong></p><p>本组Counter从宏观上量化了GPU的整体负载</p><p>并区分了Fragment与Non-Fragment任务</p><p>本组Counter可以用来判断是否GPU瓶颈，它表示GPU有任务的总时间</p><p>也可以看出两大任务队列的任务分布比例</p><p><strong>GPU Active Cycles</strong></p><p>这个Counter会在GPU的任意队列中有未完成的任务时自增</p><p>即使GPU正在因为读取System Memory而产生延迟时，也会自增</p><p>即它表示了用户程序给到GPU整体的负载压力</p><p><strong>Non-fragment queue active cycles</strong></p><p>当GPU在Non-fragment队列中有未完成的任务时，此计数器会自增</p><p>可以量化：vertex shaders, tessellation shaders, geometry shaders, fixed function tiling, compute shaders 的整体负载情况，但无法区分</p><p>同理，当产生系统内存IO延迟时，所消耗的时钟也会记录在这个Counter中</p><p><strong>Fragment queue active cycles</strong></p><p>当GPU在Fragment队列中有未完成的任务时，此计数器会自增</p><p>对大多数图形程序来讲，Fragment的负载肯定是多于Vertex的负载</p><p>因此这个队列的负载一般是最高的</p><p><strong>当你的程序的 Fragment queue active cycles 与 GPU active cycles 值大致接近时</strong></p><p><strong>你很有可能出现了瓶颈在Fragment处理上的GPU瓶颈</strong></p><p>同理，当产生系统内存IO延迟时，所消耗的时钟也会记录在这个Counter中</p><p><strong>Tiler active cycles</strong></p><p>当分块器的队列中有未完成的任务时，此计数器会自增</p><p>分快器可以和Vertex、Fragment着色任务并行进行</p><p>当此计数器很高时，不一定代表有瓶颈出现</p><p>除非Shader Core模块的Non-fragment active cycles与它对比起来低很多时</p><p>才有可能是瓶颈</p><p><strong>Interrupt pending cycles</strong></p><p>当GPU结束任务，给CPU发送Interrupt中断指令，等待CPU回复时，计数器自增</p><p>注意这些等待的Cycle并不意味着性能的损耗，因为GPU可以并行处理队列中其他任务</p><p>只有当此计数器占据了GPU active cycles中很高的比例时，才有可能有问题</p><p>也许出现了一些影响CPU处理中断效率的问题，可能是驱动层出了问题</p><p><strong>GPU utilization</strong></p><p>这组Counter数据提供了队列中任务相关cycle与GPU总cycle的归一化后的比例</p><p>对于GPU Bound的情况，理论上某条队列应该会有接近100%的利用率</p><p>因此负载最重的队列就是我们应该优先优化的目标</p><p>当你是GPU瓶颈，且GPU总是Busy，但也不是每时每刻都有队列在运行</p><p>则有可能是程序层API的使用影响了队列的并行表现</p><p>当我们想优化此类没有排满任务的情况时（GPU Bubbles），在优化最重的队列之前</p><p>首先要保证当前的负载是可以被不同的队列并行执行的</p><p>GPU Bubbles出现的可能的原因：</p><ul><li><p>CPU程序在等待GPU任务执行完毕，比如说在请求一个还未完成的数据结果。这也许会导致一个或多个队列接不到新的任务去处理</p></li><li><p>程序提交的渲染相关负载存在数据耦合，影响了并行的表现。比如一个 Fragment-&gt;Compute-&gt;Fragment 的数据输入会导致当Compute Shader执行时，不能去处理Fragment队列中的有依赖的任务</p></li></ul><p>手机GPU系统实现了动态电压调节和频率缩放系统（DVFS，dynamic voltage and frequency scaling）在执行轻度任务时，通过降低电压和频率来降低能耗</p><p>当你看到GPU Utilization比较高时，一定先看看GPU active cycles 计数器</p><p>因为GPU可能只是因为为了省电运行在一个比较低的频率下</p><p><strong>Non-fragment queue utilization</strong></p><p>此Counter记录了None-Fragment队列相对于整体GPU active cycles的利用率</p><p>在GPU瓶颈时，期望的是GPU的不同队列都是并行运行的，因此最重负载的队列利用率应接近100%</p><p>如果没有一个负载突出的队列存在，并且GPU仍然接近100%利用率</p><p>那就表明有一些序列化或依赖问题导致队列并行效率不够理想</p><p><strong>Fragment queue utilization</strong></p><p>此Counter记录了Fragment队列相对于整体GPU active cycles的利用率</p><p><strong>Tiler utilization</strong></p><p>此Counter记录了Tiler（TBR分块模块）相对于整体GPU active cycles的利用率</p><p>注意此Counter包含了索引驱动的Vertex着色过程（IDVS）的负载，与分块固定管线的负载</p><p>不仅仅代表分块固定管线的消耗</p><p><strong>Interrupt pending utilization</strong></p><p>此Counter记录的中断请求（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture">IRQ</a>)）模块相对于整体GPU active cycles的利用率</p><p><strong>在一个设计精良的系统下，IRQ的利用率应该低于2%</strong></p><p>如果此值比较高，则可能有一些系统问题导致CPU无法高效的处理中断请求</p><p><strong>External memory bandwidth</strong></p><p>此类Counters记录了GPU和下游内存系统之间的内存带宽使用情况</p><p>也许是直接和外部的DRAM交互，也许是和GPU外部的Cache系统交互</p><p>访问外部DRAM是非常费电的，比较理想的情况是每 GB&#x2F;s 的带宽需要100mW（0.1Watt）</p><p>对于高端设备<a target="_blank" rel="noopener" href="https://community.arm.com/developer/tools-software/graphics/f/discussions/49127/arm---mali---g78-mp14-power-consumption---30fps">来讲</a>（2021年4月）想以稳定频率持续运行的（CPU+GPU+memory）能耗预算大致为3.5Watts，可以出现峰值 6-8 Watts的情况，但如果长时间运行在峰值，设备就会过热</p><blockquote><p>记住降低带宽是一个很好的优化方向</p></blockquote><p>DRAM的IO是非常费电的，即使CPU、GPU Idle的情况下也需要消耗大致 1.4 Watts &#x2F; S</p><p>目前量产的 <strong>SOC</strong> 可提供总共 <strong>6-10GB&#x2F;s的DRAM带宽</strong></p><p>Arm专家推荐 <strong>GPU使用3-5GB&#x2F;s</strong> 的DRAM带宽，及如果目标是60FPS，那就是 <strong>每帧80MB</strong> 的预算</p><p>以及<strong>32 Bytes&#x2F;Vertex</strong>的数据用量</p><p>可以看到不论是HSR还是Vertex Shading，处理完顶点后有一步写入</p><blockquote><p>此顶点数据的IO操作对DRAM也有很大的影响<br>参考：<a target="_blank" rel="noopener" href="https://youtu.be/BD1zXW7Uz8Q?t=2505">Vulkanised 2023: Getting started on mobile and best practices for Arm GPUs</a></p></blockquote><p><strong>当Load&#x2F;Store单元最大的压力是DRAM带宽时</strong></p><blockquote><p>需要控制面数，面的密度。以及VertexShader中Varying参数的大小<br>（尽量用半精度，理论上只有position、depth需要全精度）<br>以控制外部DRAM写入带宽</p></blockquote><p><strong>Output external read bytes</strong></p><p>此Counter记录了GPU对外的总体读带宽：</p><p><strong>Output external write bytes</strong></p><p>此Counter记录了GPU对外的总体写带宽：</p><p><strong>External memory stalls</strong></p><p>此类Counters记录了当GPU想要从下游读写内存时，产生的等待情况的比例</p><p>如果Stall比例较高，则表明我们请求了过多的下游内存数据，超出了硬件系统可提供的范围</p><p>因此需要做一些优化内存带宽的工作</p><p><strong>Output external read stall rate</strong></p><p>此Counter记录了下游内存读取操作时产生等待的时间的比例</p><p><strong>Output external write stall rate</strong></p><p>此Counter记录了下游内存写入操作时产生等待的时间的比例</p><p><strong>External memory read latency</strong></p><p>此类Counters记录了GPU内存在进行读操作时产生的延迟比例</p><p>如果读延迟达到256cycles以上，则表明我们请求了太多内存数据，导致内存系统超负荷工作</p><p>此时就需要优化带宽</p><p><strong>Content behavior</strong></p><p>渲染性能低下通常由以下三点问题导致：</p><ul><li><p>要处理的内容很高效的被写入，但对于目标设备来讲花费了过多的机能去运算</p></li><li><p>内容写入不高效，有一些冗余的数据也被传输到渲染系统中，导致其比正常渲染更慢</p></li><li><p>CPU侧的代码对API的使用导致了高负载的任务，或者因为GPU、驱动问题导致等待的GPU Bubbles</p></li></ul><p>Streamline中此类别的Counter模板就是为了解决前两种问题</p><p>来量化提交的负载的大小和效率</p><p><strong>Geometry usage</strong></p><p>GPU渲染管线会首先处理顶点数据流</p><p>此类计数器记录了提交的Geometry总量与被剔除的总量</p><p>Geometry是GPU数据中最昂贵的输入之一，因为顶点需要32-64 bytes大小的数据读取操作，而内存读取是非常昂贵的</p><p>因此，高顶点数的高精度模型应该只在需要的时候再去提交它</p><p>倾向使用Normal Map而不是高精度的模型，多利用LOD，远处不要用太复杂的模型</p><p><strong>Total input primitives</strong></p><p><strong>Total culled primitives</strong></p><p><strong>Visible primitives</strong></p><p><strong>Geometry culling</strong></p><p>所有输入的Geomerty都必须经过剔除处理后才能知道它在相机裁剪空间的位置</p><p>因此被剔除的物体就是一项额外的消耗，即使其没有对最终的画面有贡献</p><p>这组Counters可以帮助我们了解为何三角形被剔除掉了</p><p>帮助你正确的找到出问题的地方</p><blockquote><p><a target="_blank" rel="noopener" href="https://community.arm.com/developer/tools-software/graphics/f/discussions/49160/shader-data-path-utilization-counters">Mali建议</a>Visible primitives after culling保持在50%的水平<br>Sample test cull rate过高则表示有太多密度过高的模型存在，导致其虽然在视锥中，且面向相机<br>但因为太小了没有对目标像素有贡献，从而被硬件剔除掉，浪费了GPU算力与带宽<br>利用好LOD设置，建议一个三角形大约能覆盖10-15个像素</p></blockquote><p>Mali的剔除管线流程如下图，下面介绍的Counters则表示了每一步里被干掉的模型比例</p><p><strong>IDVS shading</strong></p><p>Mali Bifrost GPU 使用了优化后的 IDVS（index-driven vertex shading） 处理管线</p><p>顶点着色被分为两步：Position、Varying Shading</p><p>Varying Shading仅发生在剔除存活后的三角形上</p><p>此组Counters记录了IDVS管线输入给Shader Core的顶点着色任务量</p><p>此管线存在变换后的顶点缓存，保存了近期被着色的顶点数据，来避免相同顶点的重复着色</p><p><strong>当模型的Index Buffer空间相关性比较差时，会导致顶点被着色多次</strong>，因为他可能已经被Cache刷掉</p><blockquote><p>考虑检测模型顶点的空间相关性，统一做自动化处理，减少重复着色？</p></blockquote><p><strong>Position shader thread invocations</strong></p><p><strong>Varying shader thread invocations</strong> <strong>Fragment overview</strong></p><p>此类Counters记录了这些GPU相关的工作负载：</p><p>被着色的像素总数、平均花费在一个像素上的GPU Cycles 数量，以及每个像素着色平均有多少面的贡献</p><p>可以设置一个Cycle预算给你们的APP，使用Cycles&#x2F;Pixel为单位</p><p>利用下面的公式计算：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 以安卓高配上游设备 Mali-G77MC9 为例，频率836MHz，9核</span><br><span class="line">// 1368x648，60FPS</span><br><span class="line">shaderCyclesPerSecond = MaliCoreCount MaliFrequency</span><br><span class="line">pixelsPerSecond = Screen_Resolution * Target_FPS</span><br><span class="line"></span><br><span class="line">shaderCyclesPerSecond = 9 * 836 * 1000000</span><br><span class="line">pixelsPerSecond = 1368 * 648 * 60</span><br><span class="line"></span><br><span class="line">// Max cycle budget assuming perfect execution</span><br><span class="line">maxBudget = shaderCyclesPerSecond / pixelsPerSecond</span><br><span class="line">maxBudget = 141</span><br><span class="line"></span><br><span class="line">// Real-world cycle budget assuming 85% utilization</span><br><span class="line">realBudget = 0.85 * maxBudget</span><br><span class="line">realBudget = 120</span><br></pre></td></tr></table></figure><p><strong>Pixels</strong></p><p>此Counter表示所有RenderPass所着色的像素数量</p><p>注意这个值可能和实际值有出入，因为内部计数硬件会对Screen宽高做Round，让他是32的倍数</p><p>即使那些像素不在屏幕里或者被裁剪掉了，也会计算上去</p><p><strong>Cycles per pixel</strong></p><p>此Counter表示每渲染一个像素所消耗的GPU cycles数量，包括顶点着色的消耗</p><p>可以用上面的公式估算出来预算</p><p><strong>Fragments per pixel</strong></p><p>此Counter表示每个像素一共有多少片元（Fragment）有贡献，即Overdraw的情况</p><p>注意：此Counter认为 tile 大小是 16x16，对于大于256bit每像素的Pass</p><p>Tile大小会自动调小，这个值就不准确了 。。。</p><p>G76： <code>($MaliCoreWarpsFragmentWarps * 8) / ($MaliCoreTilesTiles * 256)</code></p><p>G77： <code>($MaliCoreWarpsFragmentWarps * 16) / ($MaliCoreTilesTiles * 256)</code></p><p><strong>Fragment depth and stencil testing</strong></p><p>此组Counters用来看Fragment的Quads在着色时，与Early-ZS&#x2F;Late-ZS（Depth、Stencil）模块工作的情况</p><p>让尽可能多的Fragments被Early-ZS剔除掉这很重要，因为它比Late-ZS要高效得多</p><p><strong>因此Mali GPU建议将不透明物体由近至远进行排序再提交渲染</strong></p><p><strong>Early ZS tested quad percentage</strong></p><p>此Counter表示进行Early ZS测试的光栅化后的Quads的比例</p><p><strong>Early ZS updated quad percentage</strong></p><p>此Counter表示更新了FrameBuffer的光栅化后的Quads的比例</p><p><strong>Early ZS killed quad percentage</strong></p><p><strong>FPK killed quad percentage</strong></p><p>此Counter表示被Forward Pixel Kill（FPK）Hidden Surface Removal干掉的光栅化后的Quads的比例</p><p><strong>Late ZS tested quad percentage</strong></p><p><strong>Late ZS killed quad percentage</strong></p><p>此Counter表示被Late ZS干掉的光栅化后的Quads的比例</p><p>进行Late ZS检测的Quads在被干掉前，将执行部分Fragment Shader运算</p><p>因此如果Late ZS可以干掉很多Quads，意味着这里有不少的性能开销与能耗的浪费</p><p>你应该将Late ZS的Quads数量降到最低</p><p>导致Late ZS的主要原因有：</p><ul><li><p>明确使用了Discard命令</p></li><li><p>隐式使用了Discard命令（Alpha-to-coverage）</p></li><li><p>片元的Depth数值是Shader计算出来的</p></li><li><p>影响共享资源，如共享的 Storage Buffer、图片、原子变量等</p></li></ul><p>当你在Pass开始渲染时忘记清理Framebuffer的depth时，会导致驱动生成预加载ZS值的Wrap</p><p>这些额外消耗将被计算到 Late ZS 的Counter中，因此如果不需要，一定先Clear数据再渲染</p><p><strong>Shader core data path</strong></p><p>此组Counters与执行Fragment、NonFragment负载的Mali Shader Core线程发起单元有关</p><p>Non-fragment负载包含：vertex shading, geometry shading, tessellation shading, compute shading</p><p><strong>Shader core workload</strong></p><p>此组Counters表示为这两种负载发起的Wraps总数量</p><p>每个Wrap表示N个以帧同步执行的Shader线程，Wrap宽度（N）与具体GPU有关</p><p>对于Mali G76来讲，Wrap宽度是8</p><p><strong>Non-fragment warps</strong></p><p>对Compute Shader来讲，为了更全面的利用机能</p><p>所有的Compute任务组数量应该是Wrap大小的倍数</p><p><strong>Fragment warps</strong></p><p><strong>Shader core throughput</strong></p><p>此组Counters表示ShaderCore平均执行一个线程所花费的Cycles数量</p><p>注意这里指的是平均的吞吐量，而不是消耗</p><p>因此Cycles中也包含了与其相关的延迟消耗（比如内存相关延迟）</p><p><strong>Non-fragment cycles per thread</strong></p><p>此Counter表示ShaderCore平均处理一个Non-fragment线程所花费的Cycles数量</p><p>注意这里测量的是吞吐量，当值很高时不一定代表性能消耗很大</p><p>有可能是过高的内存读写延迟导致的高Cycles数量</p><p>并且还包含并行执行的Fragment、None-Fragment任务之间通信交流的消耗</p><p>因此此Counter是一个指示性的指标，不代表准确的消耗</p><p><strong>Fragment cycles per thread</strong></p><p><strong>Shader data path utilization</strong></p><p>此类Counters与ShaderCore中活动（Activity）层面的数据路径相关</p><p>帮助我们定位该关心的负载类型，以及这其中是否有任何任务安排上的问题</p><p><strong>Non-fragment utilization</strong></p><p><strong>Fragment utilization</strong></p><p><strong>Fragment FPK buffer active percentage</strong></p><p>此Counter表示花费在执行核心（Execution Core）之前的</p><p>Forward Pixel Kill Quad Buffer上的Cycle百分比，其包含至少一个Quad</p><p>根据<a target="_blank" rel="noopener" href="https://community.arm.com/developer/tools-software/graphics/f/discussions/49160/shader-data-path-utilization-counters">Arm的提示</a>，应保持此percentage尽可能地高</p><p><strong>Execution core utilization</strong></p><p>此Counter描述了可编程执行核心的利用率百分比</p><p>如果利用率比较低，则可能表示有性能损耗</p><p>因为我们有额外的Shader Core Cycle可以被用来做运算</p><p>在一些情况下，此额外消耗是无法避免的</p><p>因为Render Pass确实是有一些区域不需要进行Shader运算</p><p><strong>将优化的重点放在那些有大量冗余Geomerty的屏幕区域</strong></p><p><strong>因为Fragment前端无法更高效的生成Wrap</strong></p><p><strong>导致了可编程核心没有任务去执行</strong></p><p>这有可能是有大量的三角形被ZS或HSR剔除掉了</p><p>或者因为三角形的密度过高导致可生成的线程数量有限</p><p><strong>Shader core functional units</strong></p><p>此组Counters为我们展示了可编程Shader Core中不同的可编程、固定管线运算单元的执行情况</p><p>都是与执行Shader程序相关的硬件单元</p><p><strong>Shader unit utilization</strong></p><p>此组Counters以归一化的指标，描述了Shader Core中不同硬件单元的任务执行情况</p><p>负载最重的硬件单元是我们要关注的优化重点</p><p>当然，降低其中任意单元的负载也会对发热和功耗提供不少的帮助</p><p><strong>Execution engine utilization</strong></p><p><strong>Varying unit utilization</strong></p><p><strong>Texture unit utilization</strong></p><p><strong>Load&#x2F;store unit utilization</strong></p><p>负责从L2&#x2F;外部DRAM读取、写入数据</p><blockquote><p>即不包括从LSC（Shader Core中的Load&#x2F;Store Leve 1 Cache）的消耗，LSC一般是16KB的配置</p></blockquote><p>L2缓存是共享的缓存，包括shaders, descriptors, buffers, textures等数据，一般是2-4MiB的配置</p><p><strong>Shader workload properties</strong></p><p>此组Countes以归一化的指标，告诉我们可能影响负载执行效率的数据</p><p>也会提示我们一些潜在的有优化空间的地方</p><p><strong>Partial coverage rate</strong></p><p>此Counter表示包含没有覆盖率的Wraps的比例</p><p>如果这个比例比较高，即表示你的资源三角形密度过高，这是很耗费性能的</p><p>为了避免这种情况，使用LOD技术，让远处的资源使用精简的模型</p><p><strong>Full quad warp rate</strong></p><p>此Counter表示Quads是否完全利用了所有Wrap的比例</p><p>如果有很多Wrap没有完全利用，那么性能可能就会比较低下</p><p>因为Wrap中的可用线程没有被完全利用起来</p><p>提高Full Wrap可能的方法：</p><ul><li><p>Compute Shader 使用Wrap宽度倍数的WorkGrouops</p></li><li><p>DrawCall避免出现高密度的模型</p></li></ul><p><strong>Warp divergence percentage</strong></p><p>此Counter表示了Wrap中有出现执行分支情况的指令数的比例（G77）</p><p><strong>Diverged instruction issue rate</strong></p><p>此Counter表示了Wrap中有出现执行分支情况的指令数的比例（G76）</p><p><strong>All registers warp rate</strong></p><p>此Counter表示需要多于32个寄存器的Wrap的比例</p><p>当这个值比较高时，无法开启更多线程将会导致GPU持续忙碌</p><p>尤其是在同时内存延迟很高的情况下</p><p><strong>Constant tile kill rate</strong></p><p>此Counter表示被<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/101897/0200/fragment-shading/transaction-elimination">TE</a> CRC（<a target="_blank" rel="noopener" href="https://www.arm.com/why-arm/technologies/graphics-technologies/transaction-elimination">Transaction Elimination</a>）检查所干掉的Tile比例</p><p>如果这个值的比例比较高，就意味着你的Framebuffer每一帧都有大量的区域没有改变</p><p>尝试考虑使用裁剪矩形（Scissor Rectangles）来减少重绘的区域</p><p>与其相关的<a target="_blank" rel="noopener" href="https://community.arm.com/cn/b/blog/posts/flush">GL扩展</a>：</p><ul><li><p><a target="_blank" rel="noopener" href="https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_partial_update.txt">EGL_KHR_partial_update</a></p></li><li><p>EGL_EXT_swap_buffers_with_damage</p></li></ul><p><strong>TE是Mali的一项用于优化带宽的技术，它可以计算Tile是否相较于上一帧有所改变</strong></p><p><strong>从而重复利用那些没有改变的Tile数据，来节约运算机能的技术</strong></p><p><strong>Shader core varying unit</strong></p><p>此组Counters描述Varying Unit的使用情况</p><p>此硬件单元被用于Fragment Shader之间的插值上</p><p>此插值器有32-bit宽度的数据通道，因此16-bit的插值性能理论上是32-bit数据的两倍</p><p>因此建议在Fragment shader中使用中精度Varying的数据格式</p><p>并且建议将16-bit的值Pack到vec2&#x2F;vec4中</p><p><strong>Varying unit usage</strong></p><p><strong>Varying cycles</strong></p><p><strong>16-bit interpolation active</strong></p><p><strong>32-bit interpolation active</strong></p><p>当你的Varying unit是瓶颈时，考虑给Fragment Shader输入更多的16-bit数值以提升性能</p><p><strong>Shader core texture unit</strong></p><p>此组Counters描述了贴图单元的使用情况 包含了所有贴图采样以及过滤操作的负载</p><p><strong>Texture unit usage</strong></p><p>此组Counters表示贴图单元的使用情况，即每个指令所消耗的平均Cycle数</p><p>不同的GPU Cycles&#x2F;Sample的性能不同，比如Mali G76的最佳性能时0.5 Cycles&#x2F;Sample（双线性过滤）</p><p><strong>Texture filtering cycles</strong></p><p>此Counter表示所有与贴图过滤有关的Cycle总数</p><p>有的指令需要多于一个Cycle才可以完成，因为需要获取数据、并且做过滤</p><p>一次4个采样的Quad的消耗为：</p><ul><li><p>2D双线性过滤 2 Cycles</p></li><li><p>2D三线性过滤 4 Cycles</p></li><li><p>3D双线性过滤 4 Cycles</p></li><li><p>3D三线性过滤 8 Cycles</p></li></ul><p><strong>Texture filtering cycles per instruction</strong></p><p>此Counter表示每个指令平均花费在贴图采样上的Cycles总数</p><p>对于贴图单元是瓶颈的情况，当他的CPI比Texture samples per cycle低时</p><p>考虑使用Cycles消耗更小的贴图过滤器</p><p>不同过滤操作的更详细的性能数据见Texture issue cycles小结</p><p><strong>Texture unit workload properties</strong></p><p>此类Counters表示贴图单元中数据的表现情况</p><p>比如使用贴图压缩、Mipmap、三线性过滤等操作的数量</p><p><strong>Texture accesses using trilinear filter percentage</strong></p><p><strong>Texture accesses using mipmapped texture percentage</strong></p><p><strong>Texture unit memory usage</strong></p><p>此类Counter表示平均一个贴图采样操作所产生的L2 Cache或外部内存读取的数据大小</p><p><strong>Texture bytes read from L2 per texture cycle</strong></p><p>此Counter表示平均每个过滤Cycle中L2内存读取的数据大小</p><p>通过此Counter可判断贴图的L1 Cache情况有多好</p><p>如果每次内存读取都需要很大的L2内存带宽，你就需要看一下当前的贴图设置情况：</p><ul><li><p>离线的贴图打开mipmap</p></li><li><p>使用ASTC、ETC压缩离线贴图</p></li><li><p>修改运行时生成的FrameBuffer、贴图格式为更小的格式</p></li><li><p>降低为了锐化贴图的负的LOD偏移</p></li><li><p>降低各向异性过滤的MAX_ANISOTROPY等级</p></li></ul><p><strong>Texture bytes read from external memory per texture cycle</strong></p><p>此Counter表示平均每个过滤Cycle中系统内存读取的数据大小</p><p>通过此Counter可判断贴图的L2 Cache情况有多好</p><p>如果每次内存读取都需要很大的系统内存带宽，你就需要看一下当前的贴图设置情况</p><p><strong>Shader core load&#x2F;store unit</strong></p><p>此组Counters表示了Load&#x2F;Store单元中数据使用情况</p><p>此单元负责所有Shader 内存IO操作，除贴图和Framebuffer写回之外</p><p>表示Shader Core独有的LSC（Load&#x2F;Store L1 Cache，16K）</p><p><strong>Load&#x2F;store unit usage</strong></p><p>此Counters描述了Load&#x2F;Store单元进行读写操作的总次数</p><p>以及这些加载操作是否利用了可用数据路径的所有宽度</p><p>Compute Shader中一个关键的内存IO优化就是，更高效的利用Load&#x2F;Store硬件提供的数据宽度</p><p>我们推荐在线程中向量化内存IO操作</p><p>并且保证相同Wrap中不同线程里的有交叠或依赖的内存时，只读取64Byte范围内的数据</p><p><strong>Load&#x2F;store total issues</strong></p><p>此Counter表示产生Load&#x2F;Store操作的Cycles数</p><p>注意此Counter会忽略Cache Miss的情况，因此它提供了一个最佳情况下的Cycle消耗数据</p><p><strong>Load&#x2F;store full read issues</strong></p><p>此Counter表示所有全宽Load&#x2F;Store的缓存读取操作的Cycles数</p><p><strong>Load&#x2F;store partial read issues</strong></p><p>此Counter表示所有未完全利用Load&#x2F;Store数据路径宽度的缓存读取操作的Cycles数量</p><p>这种情况未完全利用硬件性能，可通过如下Shader修改提高利用率：</p><ul><li><p>使用向量化的数据加载</p></li><li><p>Avoid padding in strided data accesses</p></li><li><p>Compute Shader中一个Wrap中相邻的线程使用相邻的内存地址区域</p></li></ul><p><strong>Load&#x2F;store full write issues</strong></p><p>此Counter表示所有全宽Load&#x2F;Store的缓存写入操作的Cycles数</p><p><strong>Load&#x2F;store partial write issues</strong></p><p>此Counter表示所有未完全利用Load&#x2F;Store数据路径宽度的缓存写入操作的Cycles数量</p><p>这种情况未完全利用硬件性能，可通过如下Shader修改提高利用率</p><p><strong>Load&#x2F;store atomic issues</strong></p><p>此Counter表示所有Load&#x2F;Store原子操作相关的Cycles总数</p><p>原子内存读写在Wrap中的每个线程里通常是多Cycle的操作</p><p>因此它天生很耗时，避免在性能要求较高的地方使用原子内存操作</p><p><strong>Load&#x2F;store unit memory usage</strong></p><p>此组Counters表示每个Load&#x2F;Store读或写操作中平均写入或读出L2Cache的数据大小</p><p>可用于评估负载对L1、L2Cache的利用情况</p><p><strong>Load&#x2F;store bytes read from L2 per access cycle</strong></p><p>此Counter表示每个Load&#x2F;Store读操作中平均读出L2Cache的数据大小</p><p>可用于评估数据在L1 Load&#x2F;Store Cache中缓存命中的情况</p><p>如果每次获取数据都有很高的Bytes流量，则有可能与Buffer格式有关</p><p>检查一下数据类型和数据获取的方式</p><p><strong>Load&#x2F;store bytes read from external memory per access cycle</strong></p><p>此Counter表示每个Load&#x2F;Store读操作中平均读出系统内存的数据大小</p><p>可用于评估数据在L2 Load&#x2F;Store Cache中缓存命中的情况</p><p>如果每次获取数据都有很高的Bytes流量，则可能与你的贴图格式有关</p><p>同样检查一下数据类型和数据获取的方式</p><p><strong>Load&#x2F;store bytes written to L2 per access cycle</strong></p><p>此Counter表示Load&#x2F;Store单元每个写Cycle中平均写入L2缓存的数据大小</p><p><strong>Shader core memory traffic</strong></p><p>此类Counters表示不同ShaderCore模块里对L2和系统内存产生的内存IO操作的总数据大小</p><p>可用于判断内存瓶颈具体在哪里</p><p><strong>Load&#x2F;store read bytes from L2 cache</strong></p><p>此Counter表示Load&#x2F;Store单元中从L2缓存中读取的数据总大小</p><p><strong>Texture read bytes from L2 cache</strong></p><p>此Counter表示贴图单元中从L2缓存中读取的数据总大小</p><p><strong>Load&#x2F;store read bytes from external memory</strong></p><p>此Counter表示Load&#x2F;Store单元中从系统内存中读取的数据总大小</p><p><strong>Texture read bytes from external memory</strong></p><p>此Counter表示贴图单元中从系统内存中读取的数据总大小</p><p><strong>Load&#x2F;store write bytes</strong></p><p>此Couner表示Load&#x2F;Store单元中写入L2缓存的数据总大小</p><p><strong>Tile buffer write bytes</strong></p><p>此Counter表示TileBuffer写回单元中写入L2缓存的数据总大小</p><h2><span id="android-gpu-inspector-agi">Android GPU Inspector (AGI)</span></h2><p><a target="_blank" rel="noopener" href="https://developer.android.com/agi">https://developer.android.com/agi</a></p><p>Android 12系统的部分硬件：<a target="_blank" rel="noopener" href="https://developer.android.com/agi/supported-devices">https://developer.android.com/agi/supported-devices</a></p><p>可直接使用AGI输出Adreno、Mali设备的GPU Counter</p><blockquote><p>在设备允许的前提下优先使用 AGI 进行GPU性能分析</p></blockquote><h2><span id="metal-gpu">Metal GPU</span></h2><p><strong>Metal Counters</strong>可以让我们非常<strong>精确</strong>的<strong>了解GPU</strong>的使用率，并能指引我们<strong>发现Metal游戏</strong>的<strong>性能瓶颈</strong>以及<strong>优化方向</strong></p><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10603/">《Optimize Metal apps and games with GPU counters》</a>主要介绍 Instrument 中 Metal System Trace 与 XCode 12 中的 Metal Debugger 的使用方法</p><p>在<strong>抓到数据</strong>后，告诉你如何<strong>甄别</strong>GPU运算管线中 <strong>过度使用</strong> 和 <strong>未充分利用</strong>的 部分</p><p>[【公司】Apple 芯片和渲染性能优化技术专场]</p><p><strong>WWDC 2021</strong></p><ul><li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2021/10148/">Optimize high-end games for Apple GPUs</a></li></ul><p><strong>WWDC 2020</strong></p><ul><li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10631">Bring your Metal app to Apple silicon Macs</a></p></li><li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10605">Gain insights into your Metal app with Xcode 12</a></p></li><li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10602">Harness Apple GPUs with Metal</a></p></li><li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10632">Optimize Metal Performance for Apple silicon Macs</a></p></li></ul><p><strong>WWDC 2019</strong></p><ul><li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2019/606">Delivering Optimized Metal Apps and Games</a></li></ul><p><strong>WWDC 2018</strong></p><ul><li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/608">Metal Shader Debugging and Profiling</a></li></ul><h2><span id="best-practice">Best Practice</span></h2><p>降低复杂度、降低 Uber Shader 的使用（会增加寄存器压力，寄存器使用量是编译时确定的数据）</p><p>提升半精度指令的比率：包括Varing变量、Sampler、UniformBuffer</p><p>优先使用离线方案、隔帧、降频渲染、VRS</p><p>确保所有资产使用贴图压缩（ASTC、ETC2），利用硬件提供的无损、有损Framebuffer、RT压缩方案</p><h3><span id="实例一ue427-directx-shader-compiler-mobile-半精度支持">实例一：UE4.27 DirectX Shader Compiler Mobile 半精度支持</span></h3><p>大致从UE4.25开始，虚幻引擎开始逐步将Shader交叉编译器从HLSLCC（基于Mesa3d的方案）替换为DXC（Shader Conductor），本文介绍移动平台使用DXC时所做的一些优化：</p><blockquote><p>xinhou &amp; normanyin 合作撰写的相关章节 将发布于《游戏开发精粹3》中，尽请期待</p></blockquote><h3><span id="实例二使用-variable-rate-shading-插件降低-gpu-负载">实例二：使用 Variable Rate Shading 插件降低 GPU 负载</span></h3><p><a target="_blank" rel="noopener" href="https://community.arm.com/arm-community-blogs/b/graphics-gaming-and-vr-blog/posts/arm-immortalis-g715-developer-overview">https://community.arm.com/arm-community-blogs/b/graphics-gaming-and-vr-blog/posts/arm-immortalis-g715-developer-overview</a></p><h1><span id="内存">内存</span></h1><p>Android、iOS内存管理核心：</p><ol><li><p>分页（Paging）</p></li><li><p>内存映射（Memory Mapping）</p></li></ol><p>CPU &amp; GPU 公用一套内存硬件（GPU有少量OnChip Memory）</p><p>当内存不足时触发分页（Page Out）释放内存：</p><ol><li>触发 <strong>内存压缩</strong></li><li>删除Clean Page</li></ol><p>当剩余内存低于阈值，系统将开始杀进程</p><p><strong>Android：</strong></p><p><strong>iOS：</strong></p><h2><span id="堆内存分析">堆内存分析</span></h2><h3><span id="android-studio">Android Studio</span></h3><p>Android Studio 支持 Native（C++） 堆内存分配的分析工作</p><p><a target="_blank" rel="noopener" href="https://developer.android.com/studio/profile/memory-profiler">https://developer.android.com/studio/profile/memory-profiler</a></p><p>Perfetto组件可使用Heapperfd进行Native内存分析工作：</p><p><a target="_blank" rel="noopener" href="https://perfetto.dev/docs/design-docs/heapprofd-design">https://perfetto.dev/docs/design-docs/heapprofd-design</a></p><h3><span id="loliprofiler">LoliProfiler</span></h3><p>支持整合至 <a target="_blank" rel="noopener" href="https://github.com/Tencent/loli_profiler/blob/master/docs/GAME_ENGINE_CN.md">UE、Unity</a> 引擎分析 Native（C++）内存</p><p><a target="_blank" rel="noopener" href="https://github.com/Tencent/loli_profiler">https://github.com/Tencent/loli_profiler</a></p><h3><span id="custom-built-profiler">Custom Built Profiler</span></h3><p>基于LoliProfiler开发经验</p><p>堆内存分析器需要解决的核心问题：</p><ol><li><p>堆栈回溯速度：基于Framepointer方案即可</p></li><li><p>符号翻译速度：离线翻译符号、二分排序搜索加速</p></li><li><p>运行时内存占用 or 网络带宽占用</p></li></ol><p>LoliProfiler 源码均已提供对应解决方案，可整合至引擎内部</p><p>在内存中存储PersistentMap，实测内存Overhead：350 MiB，性能Overhead基本不变</p><p>输出 LoliProfiler 兼容的数据格式，即可通过 LoliProfiler打开CI数据，分析内存过大、泄漏等问题</p><h4><span id="ue5-memory-insights">UE5 Memory Insights</span></h4><p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/en-US/memory-insights-in-unreal-engine/">https://docs.unrealengine.com/5.0/en-US/memory-insights-in-unreal-engine/</a></p><p>UE5实现了类似上述方案的基于堆栈回溯堆内存分析器</p><h3><span id="unity-mono-内存">Unity Mono 内存</span></h3><p>Mono虚拟机（IL2CPP）提供内存快照接口</p><p>UnityMemPerf用C++&amp;QT完美还原了Unity IL2CPP内存工具PerfAssist的体验，无需Unity、无需SDK，连接USB拉起APP即可抓取托管内存快照，进行内存分析、快照Diff</p><h3><span id="memreport">Memreport</span></h3><p>提供 UE4 Memreport 数据解析、Diff与可视化功能：</p><h3><span id="rhi-memory">RHI Memory</span></h3><p>可针对性的对 UE Vulkan、GL、Metal RHI层内存申请接口结合 FRHIResource 的DebugName</p><p>实现一套数据Dump机制，以链接 RHI 内存与 UE RHI资源，深入分析RHI内存</p><h3><span id="xcode-allocations">XCode Allocations</span></h3><p>类似 Simpleperf 在 iOS 可查看堆内存分配数据的工具</p><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/416/">iOS Memory Deep Dive</a></p><p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/xcode/gathering-information-about-memory-use">https://developer.apple.com/documentation/xcode/gathering-information-about-memory-use</a></p><h4><span id="instrument-allocations-helper">Instrument Allocations Helper</span></h4><h2><span id="best-practice">Best Practice</span></h2><p>内存常驻数据ZSTD、Oodle压缩、文件<a target="_blank" rel="noopener" href="https://github.com/EpicGames/UnrealEngine/commit/771724018cc1a2c54af7be709cad0f094053b3ff">FileIO转Mmap</a></p><p>浮点数归一化，Lazy Load、减少UObject数量、LRU机制、Streaming</p><h3><span id="案例一运行时生成资产的-streaming-支持">案例一：运行时生成资产的 Streaming 支持</span></h3><p>手游有包体的限制，但又有变装、涂装的需求，既要又要</p><p>对于Mesh组装，我们可以将组装后的Mesh序列化到手机SD卡中，使其能够随时被Stream In、Out</p><p>对于ASTC（4x4、8x8）、ETC2贴图，可按Block进行拼装</p><blockquote><p>也可使用Compute Shader进行压缩，就可以支持 6x6 BlockSize的合并<br>代价是吞吐量有限，吞吐效率也有限</p></blockquote><p>拼装后的数据同样序列化至SD卡中，支持Stream In、Out</p><p>支持了既要又要的需求，在包体不变的情况下，运行时的DrawCall也降到了最低</p><h3><span id="案例二mesh顶点数据的归一化压缩">案例二：Mesh顶点数据的归一化压缩</span></h3><p>Mesh Position数据存在于其 Bounding Box 空间内</p><p>可通过存储 Bounding Box Center、Extent，将 Position 归一化至 ， 的数区间</p><p>Cook时使用半精度浮点数（16位）存储归一化数据</p><p>运行时仅需一个 MAD（Multiply Add）操作，即可实时解压</p><p>可以做到 Lazy Decompress，以节省相关模块的内存 </p><h1><span id="功耗">功耗</span></h1><p>手机硬件集成度高，重度手游发热明显，发热与功耗的关系越来越受到开发者的重视</p><p>推荐观看：[移动游戏能耗发热分析与优化]</p><p>功耗统计难点：</p><ol><li><p>硬件集成度高，被动散热上限低</p></li><li><p>难以测量单模块功耗</p></li><li><p>静态、动态功耗叠加</p></li><li><p>能耗和利用率、频率呈线性关系，和电压呈二次关系</p></li></ol><p>综合导致：功耗数据获取难度大，功耗数据体现非线性，数据分析难度也很大</p><p>工欲善其事，必先利其器，介绍常用的功耗测量方案，结合上述视频使用更佳：</p><h2><span id="硬件方案">硬件方案</span></h2><h3><span id="电流计">电流计</span></h3><p>优点：不需破坏手机</p><p>缺点：必须满电量测试</p><p>淘宝购买硬件设备（50RMB）</p><p>设备充满电（100%），将电流计与充电头连接。</p><p>在系统的蓝牙管理面板中查找名为“UC96_SPP”的设备，配对连接并且获取其Mac地址记下。</p><blockquote><p>分析蓝牙协议后，可实现脚本数据采集</p></blockquote><p>安卓设备建议参考WeTest方案中的方法对设备进行锁频</p><p>iOS暂无锁频方案，测试时将风扇准备上</p><h3><span id="wetest方案">Wetest方案</span></h3><p>移除设备电池，通过单片机供电并统计传输供电数据</p><p>优点：更准确</p><p>缺点：需要移除手机电池</p><blockquote><p>已知问题：<br>某些高通SoC，尤其是888，发热严重的，达到一定的温度阈值会触发SoC温控驱动自我保护机制，强制将频率控制在最低，导致我们的锁频功能失效。<br>解决方案是避免使用888这种发热严重的SoC，可以选用870等，也可以参考网上“删除android温控驱动”教程，删除驱动有极大风险，操作需谨慎。</p></blockquote><h2><span id="软件方案">软件方案</span></h2><p>Perfdog支持基于驱动上报的功耗数据获取</p><p>使用方便，准确度比硬件方案低</p><p>iOS直接解析了XCode Energy的数据</p><h2><span id="best-practice">Best Practice</span></h2><p>统计优化前后的帧功耗：AvgPower &#x3D; 平均功耗 mW&#x2F;s</p><p>减少运算量：最好的优化就是离线化，GPU带宽压缩（ASTC、AFBC）等</p><h3><span id="案例一预计算遮挡剔除-pvs">案例一：预计算遮挡剔除 PVS</span></h3><p>根据可达路径自动均匀铺设 PVS Cell</p><p>去除将需要每帧实时计算的遮挡剔除（OC）流程</p><p>降低 CPU 功耗</p><p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/VisibilityCulling/PrecomputedVisibilityVolume/">https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/VisibilityCulling/PrecomputedVisibilityVolume/</a></p><h3><span id="案例二framepacing">案例二：Framepacing</span></h3><p>在游戏图像展示在显示屏的过程中</p><p>有一个比较影响用户体验的同步过程：</p><p>游戏逻辑和渲染循环 与 安卓系统和显示屏硬件之间有一个同步的关系</p><p>这个同步过程我们称为帧节奏（<strong>Frame Pacing</strong>）</p><p>即引擎与CPU、GPU配合产生图像的帧率 与 显示屏刷新率之间的同步关系</p><p>安卓的显示系统可避免<strong>画面撕裂</strong>（ScreenTearing）的问题</p><p>即当显示器正在刷新数据时，新的数据被Push到显示设备时的情况</p><p>其通过以下措施避免撕裂（Tearing）：</p><ul><li><p>将历史帧数据缓存住</p></li><li><p>自动检测有延迟的帧数据提交</p></li><li><p>当提交有延迟时，重复渲染历史帧数据</p></li></ul><p>通过Buffer缓存帧数据，当显示器刷新时，如果有新数据传输，直接将其缓存即可</p><p>如此设计，就不会有VSYNC的阻塞式等待的问题，不增大影响游戏逻辑的输入延迟</p><p>虽然带来了一定的画面延迟，但可以避免画面撕裂问题</p><p>见[移动游戏能耗发热分析与优化]P150</p><p>[什么？FPS不是越高越好吗]</p><h1><span id="包体">包体</span></h1><p>包体的大小、首包资源的大小对于玩家有较大影响</p><p>尽可能减少包体大小，也是开发者需要关注的重点问题</p><h2><span id="sizemap">SizeMap</span></h2><p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/en-US/Engine/Basics/AssetsAndPackages/AssetManagement/CookingAndChunking/index.html#sizemap">https://docs.unrealengine.com/en-US/Engine/Basics/AssetsAndPackages/AssetManagement/CookingAndChunking/index.html#sizemap</a></p><p>打开后点击AddChunks，将本地的pak包加载进窗口：</p><p>即可打开此pak的SizeMap窗口，可以看到SizeMap以TreeMap图的形式将资源分类，我们可以点击任意分类进入更深的层级来分析数据：</p><h2><span id="unreal-pakviewer">Unreal PakViewer</span></h2><p><a target="_blank" rel="noopener" href="https://github.com/jashking/UnrealPakViewer">https://github.com/jashking/UnrealPakViewer</a></p><h2><span id="custom-built-profiler-with-ci">Custom Built Profiler With CI</span></h2><p>Asset Registry 中包含资源的 Meta 信息（AssetRegistrySearchable）</p><p>可在Cook &amp; Package 结束后使用 Commandlet 分析此信息</p><p>得出进包资产的压缩数据，输出CI报告监控包体</p><h2><span id="best-practice">Best Practice</span></h2><p>冗余资源不进包，贴图压缩（ASTC、ETC2）、充分利用 ASTC 8x8</p><p>ZSTD压缩、Oodle压缩，数据 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rate%E2%80%93distortion_optimization">RDO</a> 压缩</p><h3><span id="案例一glsl-spirv-shader数据压缩">案例一：GLSL、SPIRV Shader数据压缩</span></h3><p>GLSL可通过 ZSTD+字典 的形式做到极致的包体压缩</p><p>[基于ZSTD字典的Shader压缩方案]</p><p>Vulkan SPIRV可使用 <a target="_blank" rel="noopener" href="https://github.com/aras-p/smol-v">SMOL-V</a> 进行 RDO 优化，从而达到极致的包体压缩</p><h1><span id="代码崩溃-amp-稳定性">代码崩溃 &amp; 稳定性</span></h1><p>疑难崩溃通常发生于非第一现场，需要花费大量<strong>人力</strong>和<strong>精力</strong>和<strong>心情</strong>❤去分析</p><p>是性价比最低的开发工作之一 😢</p><p>除了提升代码质量之外，如何提前发现可能的疑难崩溃，将其尽可能早的暴漏出来</p><p>是大型项目开发过程中需要考虑与解决的重点问题之一</p><p>Tips：可通过addr2line翻译崩溃符号至具体代码行号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># android-ndk-r21d\toolchains\aarch64-linux-android-4.9\prebuilt\windows-x86_64\bin\aarch64-linux-android-addr2line.exe</span></span><br><span class="line">addr2line.exe -f -C -e path/to/libUE4.so 0x009988ff</span><br></pre></td></tr></table></figure><h2><span id="address-santizer">Address Santizer</span></h2><p>Android、iOS平台原生支持 ASan，UE也已整合至引擎中</p><p>日常通过冒烟测试ASan包，提前发现内存越界、Use-after-free等常见内存问题</p><p>将不属于你的崩溃，提前拒之门外，降低开发负担</p><p>[安卓平台使用ASan检查UE4内存问题]</p><h2><span id="stompallocator">StompAllocator</span></h2><p>Windows平台也支持ASan，不行的是至少4.27版本的引擎仍旧无法正常使用ASan功能</p><p>可使用替代品，UE内部的 Stomp Allocator（会占用巨量虚拟内存（60G+））</p><p><a target="_blank" rel="noopener" href="https://pzurita.wordpress.com/2015/06/29/memory-stomp-allocator-for-unreal-engine-4/">https://pzurita.wordpress.com/2015/06/29/memory-stomp-allocator-for-unreal-engine-4/</a></p><p>通过Page可以设置Read、Write保护的特性，在每次申请内存时，使用Page读写保护来保护内存区域</p><p>当越界读写时，就会触发保护，从而崩溃在问题出现的第一现场</p><h3><span id="案例一stompallocator崩溃分析">案例一：StompAllocator崩溃分析</span></h3><p>打开Stomp Allocator崩溃于第一现场</p><p>基类获取了Hits数组的地址</p><p>当其所在vector容器扩容时，会产生realloc，导致基类中的指向Hits的地址失效</p><p>正常情况下，realloc，老地址回Malloc池，如果这块内存仍未立即被使用，这块代码仍可正常执行</p><p>当这块老代码被其他模块使用，而Hits数据再次被修改时，就会出错</p><p>解决方法：</p><p>这种指向自己成员内存地址的对象，放在vector、TArray容器里再resize后都会有风险</p><p>临时修的话加个resize0，或者resize后assign(size, T())</p><p><strong>最好避免这种写法</strong></p><h2><span id="vulkan">Vulkan</span></h2><p>Vulkan RHI在较新的移动设备中已全面支持</p><p>其RHI性能、驱动内存占用，可玩性、以及可优化性 远超 OpenGL RHI</p><h3><span id="vulkan-validation">Vulkan Validation</span></h3><blockquote><p>Device Lost崩溃时绝望有多少、这张图就有多大</p></blockquote><p>想要避免Device Lost问题？首先要确保项目中已清空 Validation Error</p><p>[在UE4中吃好Vulkan的螃蟹-vulkan-validation-layer]</p><p>Validation Layer是Debug Vulkan RHI行为的必备工具</p><p>在UE4中以Log的形式报告出RHI层的错误用法以及潜在的性能问题：</p><h3><span id="vulkan-command-replay">Vulkan Command Replay</span></h3><blockquote><p>优先选择寻找崩溃设备的厂商进行支持</p></blockquote><p>Vulkan 作为新兴 RHI，有一系列辅助开发的工具，其中就包含Command的Trace工具</p><p><a target="_blank" rel="noopener" href="https://github.com/LunarG/gfxreconstruct">https://github.com/LunarG/gfxreconstruct</a></p><p>发现崩溃问题时，可通过Trace工具记录完整Command数据</p><p>通过二分回放定位问题Command</p><p>回放功能兼容UE4、5的重点在于处理好进程的信号处理接口</p><p>因为其数据采集部分功能基于此接口实现</p><p><a target="_blank" rel="noopener" href="https://github.com/LunarG/gfxreconstruct/issues/990">https://github.com/LunarG/gfxreconstruct/issues/990</a></p><div class="copyright-box"><div class="license-box"><div class="license-header"><div class="license-title">UE性能优化工具</div><div class="license-subTitle">https://hustjjd.github.io/3c5e942.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div><a href="">Davids</a></div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2025年8月10日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名">BY - 署名</span></a></div></div></div></div></div></div><script async reload>fetch("https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/tokyo-night-dark.css").then(e=>e.text()).then(e=>{const l=document.createElement("style");e=e.replace(".hljs-code,","").replaceAll("_"," ").replaceAll("hljs-","hljs .").replaceAll(".hljs"," .highlight").replaceAll(".built in",".built_in").replaceAll("title.","");document.querySelectorAll("figure.highlight td.gutter").forEach(e=>{e.classList.add("highlight")}),l.innerHTML=e,document.head.appendChild(l)}).catch(e=>{console.error("Error loading CSS:",e)})</script><script reload>var targets=document.querySelectorAll("figure.highlight, #article-content > pre:not(.highlight,.hljs)");targets.forEach(e=>{const t=document.createElement("button");t.innerHTML='<i class="fa fa-clone" aria-hidden="true"></i>',t.className="code-copy",t.style.color="#fff",t.addEventListener("click",()=>{const n=e.querySelector("td.code")?.textContent||e.querySelector("code")?.textContent;navigator.clipboard.writeText(n).then(()=>{t.innerHTML="Copied!",setTimeout(()=>{t.innerHTML='<i class="fa fa-clone" aria-hidden="true"></i>'},2e3)})}),e.appendChild(t)})</script><div class="post-guide"><div class="item left"><a href="f2421617.html"><i class="fa fa-angle-left" aria-hidden="true"></i> UObject</a></div><div class="item right"><a href="558c8778.html">Unlua指南<i class="fa fa-angle-right" aria-hidden="true"></i></a></div></div></div><div id="footer"><div>©2024<span>-</span><span>2025</span> <a href="">Davids</a> <span id="busuanzi_container_site_pv">总访问量<span id="vercount_value_page_pv"></span></span> <span id="busuanzi_container_site_uv">总访客数<span id="vercount_value_site_pv"></span></span></div><div>Theme <a href="https://github.com/Exisi/hexo-theme-node-tree" target="_blank">Node-Tree</a> Powered by <a href="https://hexo.io" target="_blank">Hexo</a></div></div><button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button><script async>const topTopBtn=document.querySelector("#totop-toggle");topTopBtn.addEventListener("click",()=>{window.scrollTo({top:0,behavior:"smooth"})})</script></body></html>